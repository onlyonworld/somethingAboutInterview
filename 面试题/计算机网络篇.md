### 1、HTTP协议及HTTP缓存

​		超文本传输协议（HTTP，HyperText Transfer Protocol)是一种实现客户端和服务器之间通信的响应协议，它是用作客户端和服务器之间的请求。

**HTTP特性**

HTTP 是无连接无状态的
HTTP 一般构建于 TCP/IP 协议之上，默认端口号是 80
HTTP 可以分为两个部分，即请求和响应。

**HTTP** 常用的协议包括哪些请求？

GET、POST、PUT、DELETE

URL 全称为资源描述符，可以这么认为：一个 URL 地址对应着一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE就对应着对这个资源的查询，修改，增添，删除4个操作。

HTTP 请求由 3 个部分构成，分别是：状态行，请求头(Request Header)，请求正文。

HTTP 响应由 3 个部分构成，分别是：状态行，响应头(Response Header)，响应正文

#### **HTTP缓存机制(浏览器缓存机制)**

http缓存分为**强缓存**与**协商缓存**

强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。

​		用户发起了一个`http`请求后，浏览器发现先本地已有所请求资源的缓存，便开始检查缓存是否过期。有两个`http`头部字段控制缓存的有效期：`Expires`和`cache-Control`，浏览器是根据以下两步来判定缓存是否过期的：
1) 查看缓存是否有`cache-Control`的`s-maxage`或`max-age`指令，若有，则使用响应报文生成时间`Date + s-maxage/max-age`获得过期时间，再与当前时间进行对比 (s-maxage适用于多用户使用的公共缓存服务器);
2) 如果没有`cache-Control`的`s-maxage`或`max-age`指令，则比较`Expires`中的过期时间与当前时间。`Expires`是一个绝对时间。

协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。

​		当第一次请求时服务器返回的响应头中没有`Cache-Control`和`Expires`或者`Cache-Control`和`Expires`过期还或者它的属性设置为`no-cache`时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。

​	浏览器第一次发出请求一个资源的时候，服务器会返回一个`Last-Modify`到hearer中， `Last-Modify`含义是最后的修改时间。当浏览器再次请求的时候，`request`的请求头会加上`if-Modify-Since`，该值为缓存之前返回的`Last-Modify`。服务器收到`if-Modify-Since`后，根据资源的最后修改时间`(last-Modify)`和该值`(if-Modify-Since)`进行比较，如果相等的话，则命中缓存，返回304，否则, 如果`Last-Modify > if-Modify-Since`, 则会给出200响应，并且更新`Last-Modify`为新的值。

### 2、HTTP 中， POST与 GET 的区别

1）Get是在请求过程中会把数据暴露在url上，不安全，而post不会

2)  Get请求传送的数据量小，受到地址栏长度影响，最多只能2k；而Post可以传送的数据量大，一般默认为不受限制。

3)  Get可以保存为书签，而post不行

4)  Get的参数只能是ASCII，而Post没有要求

**get和post的content-type是什么意思？**

`content-type`是用来指定消息体的格式的，一般来说get不需要设置，而post需要设置。

### 3、HTTP与HTTPS

① https协议需要到ca申请证书或自制证书。

② http的信息是明文传输，https则是具有安全性的ssl加密。

③ http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。

④ http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

**HTTPS建立连接的过程**

```js
(1) 浏览器发送一个连接请求给服务器;服务器将自己的证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息返回客户端;
(2) 客户端浏览器检查服务器传送到CA证书是否由自己信赖的CA中心签发。若是，执行4步;否则，给客户一个警告信息：询问是否继续访问。
(3) 客户端浏览器比较证书里的信息，如证书有效期、服务器域名和公钥S_PK，与服务器传回的信息是否一致，如果一致，则浏览器完成对服务器的身份认证。
(4) 服务器要求客户端发送客户端证书(包含客户端公钥C_PuKey)、支持的对称加密方案及其他相关信息。收到后，服务器进行相同的身份认证，若没有通过验证，则拒绝连接;
(5) 服务器根据客户端浏览器发送到密码种类，选择一种加密程度最高的方案，用客户端公钥C_PuKey加密后通知到浏览器;
(6) 客户端通过私钥C_PrKey解密后，得知服务器选择的加密方案，并选择一个通话密钥key（即对称加密的key），接着用服务器公钥S_PuKey加密后发送给服务器;
(7) 服务器接收到的浏览器传送到消息，用私钥S_PrKey解密，获得通话密钥key。
(8) 接下来的数据传输都使用该对称密钥key进行加密。
```

### 4、了解基本的浏览器渲染

​	①解析HTML生成DOM树
​	②解析CSS生成CSSOM规则树
​	③将DOM树与CSSOM规则树合并在一起生成渲染树Render Tree。
​	④遍历渲染树开始布局，计算每个节点的位置大小信息
​	⑤将渲染树每个节点绘制到屏幕

#### 	4.1 css加载会不会阻塞页面渲染,为什么？

​		css加载会阻断页面的渲染；

​		原因：浏览器渲染页面时，DOM解析和CSS解析是两个并行的进程，此时CSS加载不会阻塞DOM的解析，但是渲染树的渲染是依赖于DOM树和CSS树的，必须等待到CSS树构建完成才能渲染，CSS没有加载完成，CSS树没有构建完成，渲染就不会开始，所以CSS加载是会阻塞Dom的渲染的；由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

### 5、三次握手四次挥手

**为什么要三次握手？**

​		说法1：在只有两次“握手”的情形下，假设客户端想跟服务器建立连接，但是却因为中途连接请求的数据报丢失了，故客户端不得不重新发送一遍；这个时候服务器端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候客户端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下服务器端将先后收到2次请求，并持续等待两个客户端请求向他发送数据...问题就在这里，客户端实际上只有一次请求，而服务器端却有2个响应，极端的情况可能由于客户端端多次重新发送请求数据而导致服务器端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

​		说法2：client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，知道某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。

**为什么要四次挥手？**

​		假如现在你是客户端你想断开跟服务器的所有连接，第一步，你自己先停止向服务器端发送数据，并等待服务器的回复。但事情还没有完，虽然你自身不往服务器发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故服务器端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

​		TCP建立连接要进行3次握手，而断开连接要进行4次：这是由于TCP的半关闭造成的，因为TCP连接是全双工的(即数据可在两个方向上同时传递)，所以进行关闭时每个方向上都要单独进行关闭，这个单方向的关闭就叫半关闭。关闭的方法是一方完成它的数据传输后，就发送一个FIN来向另一方通告将要终止这个方向的连接。当一端收到一个FIN,它必须通知应用层TCP连接已终止了这个方向的数据传送，发送FIN通常是应用层进行关闭的结果。

### 6、常见状态码及原因短语

```javascript
200 OK 客户端请求成功。
301 Moved Permanently 请求永久重定向。
302 Moved Temporarily 请求临时重定向。
304 Not Modified 文件未修改，可以直接使用缓存的文件。
400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized 请求未经授权，无法访问。
403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
404 Not Found 请求的资源不存在，比如输入了错误的URL。
500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。
```

### 7、层次划分

<img src="D:\typora笔记\面试.assets\image-20200706203651364.png" alt="image-20200706203651364" style="zoom:50%;" />

数据链路层的协议：SDLC、HDLC、PPP、STP

网络层：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF

传输层：TCP、UDP

应用层：FTP、SMTP、HTTP

### 8、TCP协议和UDP协议

TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要通过四次挥手拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象。

**TCP** **与** **UDP** **的区别：**

TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。

UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

### 9、TCP滑动窗口

TCP滑动窗口具有拥塞控制和保证可靠性的功能

对于拥塞控制，滑动窗口是可变大小的，如果滑动窗口发生拥塞控制则将窗口大小置为1，然后对长度进行2的指数增长，直到窗口大小可满足数据传输或者大小到达阈值。

对于可靠性，接收双方具有同样大小的窗口，然后对数据进行编号，如果接收端没有收到某部分信息就会发送请求给发送方然后重新发送未接收到的部分。

### 10、HTTP报文内容

<img src="D:\typora笔记\面试.assets\image-20201013001157290.png" alt="image-20201013001157290" style="zoom:50%;" />

https://www.cnblogs.com/myseries/p/11239662.html