# 小程序基础知识点

## 一、小程序项目的结构

### 1、pages

pages文件夹是小程序的页面，一个子文件夹代表一个页面；

一个子文件夹下默认有四个文件：`js`文件、json文件、wxml文件、wxss文件。

​	js文件：小程序页面的逻辑层

​	json文件：小程序页面的配置

​	wxml文件：小程序页面骨架，相当于web前端中的html文件

​	wxss文件：小程序页面样式，相当于web前端中的css文件

### 2、utils

utils文件夹可以用来存放小程序的公用方法，是一个工具文件，通过module.exports将方法导出，提供给其他页面使用

### 3、app.js

小程序主要逻辑层，用来注册小程序，一定要有。

通过App()这个方法注册小程序，在其他页面可以通过getApp()这个方法来获取应用实例。

举个栗子：

```js
// app.js文件代码
App({
    globalData: {
		userInfo: 'balabala'
    }
})
// 在其他页面的js文件中
const app = getApp()
// 通过 app.globalData.userInfo可以获取到app.js文件中的数据
```

### 4、app.json

小程序的公共配置，一定要有

```json
{
  // pages代表小程序页面路由，我们可以在这里配置页面，排在第一个的路由代表启动小程序时的初始页面
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  // window主要是用来配置窗口的信息及样式
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json" // 站点文件，主要写小程序的一些索引，方便微信搜索，提高曝光率
}
```

小程序页面中的json文件配置会覆盖掉这些公共的配置

### 5、app.wxss

小程序的公共样式，可有可无

小程序页面中的wxss文件配置会覆盖掉这些公共的样式

### 6、project.config.json

项目配置文件，新建项目时自动生成，自动写好，一般不需要去修改它

### 如何新建一个页面

首先，在pages文件夹下新建一个文件夹，用来表示需要新建的页面，鼠标右击新建的文件夹，选择新建Page，自动生成页面默认所需的四个文件

然后，在app.json文件中的pages添加新建页面的路径

## 二、小程序基础组件以及特有的尺寸单位

### 基础组件

#### 0、view

小程序中没有div、span等标签，它的view标签就相当于web前端中的div标签

**view不是小程序的基础组件**

#### 1、text

相当于web前端中的span标签，其space的有效值和富文本的space属性有效值一样

| 属性        | 类型    | 默认值 | 必填 | 说明                                                | 最低版本                                                     |
| :---------- | :------ | :----- | :--- | :-------------------------------------------------- | :----------------------------------------------------------- |
| selectable  | boolean | false  | 否   | 文本是否可选 (已废弃)                               | [1.1.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| user-select | boolean | false  | 否   | 文本是否可选，该属性会使文本节点显示为 inline-block | [2.12.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| space       | string  |        | 否   | 显示连续空格                                        | [1.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| decode      | boolean | false  | 否   | 是否解码                                            | [1.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

#### 2、icon

icon图标，组件长度单位默认是px，有三个属性：color、size、type

①type：必填项，有效值：success、success_no_circle、info、warn、waiting、cancel、download、search、clear

![image-20210115132125781](D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210115132125781.png)

②size：选填项，默认值是23

③color：选填项

#### 3、progress

进度条，常用的有个属性：percent、show-info、border-radius

①percent：选填项，进度条百分比，值是0~100的数值类型

②show-info：选填项，是否显示进度条百分比，默认值是false

③border-radius：选填项，进度条四个角的圆角弧度，默认值是0，其值后面不需要加单位

④font-size：选填项，设置show-info百分比字体大小，默认是16

⑤stroke-width：选填项，进度条线的宽度，默认是6

⑥activeColor：选填项，进度条颜色，默认是绿色

⑦backgroundColor：选填项，进度条背景颜色，默认是白色

⑧active：进度条动画，默认为false

#### 4、rich-text

富文本，有两个属性：nodes、space

①nodes：选填项，其值可以为节点列表/HTML String，即可以传入HTML标签

```html
<rich-text nodes="{{nodeStr}}"></rich-text>
```

```javascript
// 简写方法
data: {
	nodeStr: "<div class='div-class' style='line-height: 20px; color: blue;'>Hello&nbsp;World!</div>"
}
// 官方写法
data: {
	nodeStr: [{
        name:　'div',
        attrs: {
            class: 'div-class',
            style: 'line-height: 20px; color: blue;'
        },
        children: [{
            type: text,
            text: 'Hello&nbsp;World!'
        }]
    }]
}
```

②space：选填项，有三个有效值：

| 值   | 说明                   | 最低版本 |
| :--- | :--------------------- | :------- |
| ensp | 中文字符空格一半大小   |          |
| emsp | 中文字符空格大小       |          |
| nbsp | 根据字体设置的空格大小 |          |

### 尺寸单位rpx

可以根据屏幕宽度自适应，规定屏幕宽度为750px

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210113154836616.png" alt="image-20210113154836616" style="zoom:50%;" />



### slot插槽

小程序的slot插槽和HTML的slot插槽用法类似，用于拓展组件的功能，用户可以根据自己的需要增加一些扩展性内容。

小程序中的slot插槽不做特殊声明，一个组件只能有一个slot插槽，如果一个组件需要多个插槽，需要在组件的js文件中添加：options: { multipleSlots: true }，使得组件可以有多个插槽，不同的插槽通过name属性赋予不同的名字，在使用通过slot="slot name"将内容插到对应的插槽中。

```html
<!-- 组件的wxml代码 -->
<view>
    <slot name="slot1"></slot>
    <view>这是一组件</view>
    <slot name="slot2"></slot>
</view>    
```

```js
// 组件的js代码
Component({
    options: {
        multipleSlots: true
    }
})
```

```html
<!-- 引入组件的组件或者页面的wxml文件代码 -->
<view>
	<my-component>
    	<view slot="slot1">
        	在slot1中插入内容
        </view>
    </my-component>
</view>
```

```js
// 引入组件的组件或者页面的json文件代码
{
    "component": true,
    "usingComponents": {
        "myComponent": "组件所在地址"
    }
}
```

## 三、小程序生命周期

### 1、onLaunch

监听小程序初始化

### 2、onShow

监听小程序启动或者切前台的操作

### 3、onHide

监听小程序切后台的操作

### 4、onError

错误监听函数，当小程序发生错误时触发

### 5、onPageNotFound

页面不存在监听函数，当页面不存在时触发

## 四、小程序页面的生命周期

### 1、onLoad

监听页面加载，当页面加载完成后触发

### 2、onShow

监听页面显示，当页面显示出来时触发

### 3、onReady

监听页面初次渲染完成，当页面渲染完成后触发

### 4、onHide

监听页面隐藏，切后台或者切换到其他页面均会触发这个函数

### 5、onUnload

监听页面卸载，关闭当前页面时触发

### **注意**

每个页面的onLoad、onReady函数只会触发一次，此后即使跳转到其他页面再跳转回来，也不会再次触发

## 五、小程序知识点

### 1、小程序没有DOM

小程序没有DOM概念，所以在js文件中无法使用document.getElementById()等等来获取页面中的DOM元素

### 2、数据绑定

小程序的数据绑定是单向数据绑定，使用{{}}进行数据绑定，这点与vue一样，但是vue是数据双向绑定；

### 3、数据赋值

```js
/* 在vue中 */
data() {
    str: 'jack',
    age: 18
}
// 改变data中的值
this.str = 'john' // 这样页面(视图)上数据也会跟着改变

/* 在小程序中 */
data: {
    str: 'jack',
    age: 18
}
// 改变data中的值
this.data.str = 'john' // 由于小程序是数据单向绑定，赋值之后页面数据并不会变化
this.setData(this.data) // 调用this.setData()，驱动视图更新
```

### 4、条件渲染

```html
<!-- 在vue中 -->
<div v-if="flag"></div>
<div v-else-if="flag"></div>
<div v-else></div>
<!-- 在小程序中 -->
<view wx:if="{{flag}}"></view>
<view wx:elif="{{flag}}"></view>
<view wx:else></view>
```

### 5、循环渲染

```html
<!-- 在vue中 -->
<div v-for="(item, index) in list" :key="item.id">
	......
</div>

<!-- 在小程序中 -->
<block wx:for="{{ list }}" wx:for-item="item" wx:key="id" wx:for-index="index">
	<!-- 
		可以使用block标签，也可以使用view标签；
		在小程序中使用循环渲染和vue有较大的区别，可以不声明wx:for-item和wx:for-index，然后直接使用item和index来表示列表的每一项和索引值，这个是默认的，可以不写出来，绑定key值时直接使用列表项中的唯一值，不需要像vue一样使用item.id
	-->
</block>
```

### 6、小程序事件

小程序在绑定事件时需要在事件前面加bind，以下事件都是冒泡事件

#### 6.1 tap

触摸后马上离开时触发，相当于点击事件

```html
<!-- 在vue中，v-on:可以缩写为@ -->
<button v-on:click="changeSomething()">点击按钮</button>
<button @click="changeSomething()">点击按钮</button>

<!-- 在小程序中，bind后面的:可以省略 -->
<button bind:tap="changeSomething">点击按钮</button>
<button bindtap="changeSomething">点击按钮</button>
```

#### 6.2 touchstart

手指触摸动作开始时触发

#### 6.3 touchmove

手指触摸后移动

#### 6.4 touchcancel

手指触摸动作被打断，如来电提醒，弹窗

#### 6.5 touchend

手指触摸动作结束

#### 6.6 longpress

手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发

#### 6.7 longtap

手指触摸后，超过350ms再离开(推荐使用longpress事件代替)

### 7、小程序中catch和bind的区别

bind会触发事件冒泡机制

catch会阻止事件冒泡

```html
<view bindtap="containerPrint">
    <text bindtap="textPrint">文本</text>
</view>

<view bindtap="containerPrint">
    <text catchtap="textPrint">文本</text>
</view>

<view catchtap="containerPrint">
    <text catchtap="textPrint">文本</text>
</view>
```

```js
containerPrint: function() {
	console.log("container")
},
textPrint: function() {
	console.log("text")
}
// 第一个view中，点击text文本时由于冒泡事件，会触发父元素上对应的事件
// 第二和第三个view中，点击text均不会触发父元素上的对应的事件
```

### 8、小程序事件冒泡与捕获

```html
<!-- 在小程序中，
	事件捕获阶段使用capture-bind，后面冒号不能省略；
	中断事件捕获阶段用capture-catch，但是同时冒泡事件也被取消了
-->
<view bindtap="containerTap" capture-bind:tap="captureTap">
	<text bindtap="txtTap" capture-bind:tap="captureTap2">小程序</text>
</view>
<!--
	当点击文本时，输出captureTap、captureTap2、text、container
    先是事件捕获阶段，触发父元素上的capture-bind:tap事件以及子元素上的capture-bind:tap事件
    然后是事件冒泡阶段，触发子元素上的bindtap事件以及父元素上的bindtap事件
-->
<view bindtap="containerTap" capture-bind:tap="captureTap">
	<text bindtap="txtTap" capture-catch:tap="captureTap2">小程序</text>
</view>
<!--
	当点击文本时，输出captureTap、captureTap2
    先是事件捕获阶段，触发父元素上的capture-bind:tap事件以及子元素上的capture-catch:tap事件
	但是子元素使用了中断事件捕获和取消事件冒泡的capture-catch:tap，导致后面的text、container没有输出
-->
```

```js
containerTap: function() {
	console.log("container")
},
captureTap: function() {
	console.log("captureTap")
},
txtTap: function() {
	console.log("text")
},
captureTap2: function() {
	console.log("captureTap2")
}
```

## 六、小程序的from表单组件

### 1、input

小程序的input组件和html的input组件类似，区别在于方法的绑定不同，常见的事件有：bindinput(键盘输入时触发)、bindfocus(输入框聚焦时触发)、bindblur(输入框失去焦点时触发)、bindconfirm(点击完成按钮时触发)；

input有一个属性为password，默认为false，当输入框为输入密码时，将该属性赋为true即可，而不是将type设置为password

具体可以参考：https://developers.weixin.qq.com/miniprogram/dev/component/input.html

### 2、checkbox和radio以及checkbox-group和radio-group

小程序的checkbox、radio的用法跟HTML的一样

checkbox-group、radio-group有一个绑定的事件：bindchange，当checkbox-group/radio-group里面的选项发生变化时触发

由于小程序是数据单向绑定，如果要给checkbox的checked一个默认值，当点击选择/取消时需要手动改变原先的默认值

### 3、textarea

文本框，用法和HTML中的textarea标签一样，属性中有一个auto-height，表示是否自动增高，设置auto-height时，style.height不生效

### 4、form

form组件有两个常用的事件：bindsubmit和bindreset，当点击的button的form-type为submit时，会触发form表单的bindsubmit事件，当点击的button的form-type为reset时，会触发form表单的bindreset事件

### 5、button

在form表单中主要用来做提交按钮和重置按钮，其对应的form-type为submit和reset，不过需要注意的一点是，使用提交或者重置按钮，需要给标签一个name属性。

**举个栗子**

```html
<form bindsubmit="formSubmit" bindreset="formReset">
    <view>
        <view>输入框input</view>
        <input type="text" name="name" placeholder="请输入姓名" value="{{inputName}}" bindinput="inputName" />
        <input type="text" name="age" placeholder="请输入年龄" value="{{inputAge}}" bindinput="inputAge" />
    </view>
    <view>
        <view>复选框</view>
        <checkbox-group name="fruit" bindchange="cbChange">
            <block wx:for="{{fruitList}}" wx:for-item="fruit" wx:key="value">
                <checkbox value="{{fruit.value}}" />{{fruit.label}}
            </block>
        </checkbox-group>
    </view>
    <view>
        <view>单选框</view>
        <radio-group name="food" bindchange="radioChange">
            <block wx:for="{{foodList}}" wx:for-item="food" wx:key="value">
                <radio value="{{food.value}}" ></radio>{{food.label}}
            </block>
        </radio-group>
    </view>
    <view>
        <button form-type="submit">提交</button>
    </view>
    <view>
        <button form-type="reset">重置</button>
    </view>
</form>

```

```js
data: {
    inputName: '',
    inputAge: '', // 用来保存input输入框的内容
    cbVal: '', // 用来保存checkbox复选框的选中项
    radioVal: '', // 用来保存radio单选框的选中项
    fruitList: [
        {
            label: 'apple',
            value: 'apple'
        },
        {
            label: 'banana',
            value: 'banana'
        },
        {
            label: 'pear',
            value: 'pear'
        },
        {
            label: 'orange',
            value: 'orange'
        },
    ],
    foodList: [
        {
            label: 'cake',
            value: 'cake'
        },
        {
            label: 'snake',
            value: 'snake'
        },
        {
            label: 'bear',
            value: 'bear'
        },
        {
            label: 'beaf',
            value: 'beaf'
        },
    ]
},

inputName: function(e) {
    this.data.inputName = e.detail.value
    this.setData(this.data)
},
inputAge: function(e) {
    this.data.inputAge = e.detail.value
    this.setData(this.data)
},

cbChange: function(e) {
    this.data.cbVal = e.detail.value
    this.setData(this.data)
},

radioChange: function(e) {
    this.data.radioVal = e.detail.value
    this.setData(this.data)
},

formSubmit: function(e) {
    console.log(e.detail)
}, // 点击提交后可以查看每一项的数据
formReset: function(e) {
    console.log(e.detail)
} // 点击重置后数据被清空
```

![image-20210115204633218](D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210115204633218.png)

![image-20210115204730591](D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210115204730591.png)

### 6、picker

选择器，主要有两个属性(range、value和mode)和一个绑定事件(bindchange)

range的值是一个数组，每个元素对应一个选项，当mode为selector或multiSelector时有效

value的值是数组对应的下标，表示要显示的数组元素的下标

mode表示选择器类型，默认是selector，其合法值如下：

| 值            | 说明         | 最低版本 |
| :------------ | :----------- | :------- |
| selector      | 普通选择器   |          |
| multiSelector | 多列选择器   |          |
| time          | 时间选择器   |          |
| date          | 日期选择器   |          |
| region        | 省市区选择器 |          |

当mode取不同的值时，有对应的不同的属性

```html
<view class="picker">
    <view>选择器picker</view>
    <picker name="course-picker" bindchange="pickerChange" range="{{courses}}" value="{{course_index}}">
        课程选择：{{courses[course_index]}}
    </picker>
    <picker name="number-picker" mode="multiSelector" bindchange="num_pickerChange" range="{{nums}}" value="{{num_index}}">
        数字选择：<text wx:for="{{num_index}}" wx:key="index">
            {{nums[index][num_index[index]]}}
        </text>
    </picker>
    <picker name="time" mode="time" bindchange="time_pickerChange" value="{{time}}" start="00:00" end="23:59">
        时间选择：{{time}}
    </picker>
    <picker name="date" mode="date" bindchange="date_pickerChange" value="{{date}}" start="2021-01-01" end="2021-12-31">
        日期选择：{{date}}
    </picker>
    <picker name="address" mode="region" bindchange="addr_pickerChange" value="{{address}}">
        当前选择的地区：{{address[0]}}/{{address[1]}}/{{address[2]}}
    </picker>
</view>
```

```js
data: {
	courses: ['数据结构', 'java', 'c++', 'javascript', 'HTML+CSS'],
    course_index: 0,
    nums: [['a', 'b', 'c'], ['c', 'd', 'e', 'f'], ['g', 'h']],
    num_index: [1, 3, 0],
    time: '',
    date: '',
    address: [
},
pickerChange: function(e) {
    this.setData({
        course_index: e.detail.value
    })
},
num_pickerChange: function(e) {
    this.setData({
        num_index: e.detail.value
    })
},
time_pickerChange: function(e) {
    this.setData({
        time: e.detail.value
    })
},
date_pickerChange: function(e) {
    this.setData({
        date: e.detail.value
    })
},
addr_pickerChange: function(e) {
    this.setData({
        address: e.detail.value
    })
},
```

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210116183630492.png" alt="image-20210116183630492" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210116183653543.png" alt="image-20210116183653543" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210116183713507.png" alt="image-20210116183713507" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210116183733932.png" alt="image-20210116183733932" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210116183750361.png" alt="image-20210116183750361" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210116183808555.png" alt="image-20210116183808555" style="zoom:50%;" />

### 7、slider

滑动选择器

```html
<view>
    滑动选择器
    <slider name="slider" bindchange="sliderChange" value="{{sliderVal}}" min="0" max="100" show-value="true" step="2" activeColor="#54de65"></slider>
</view>
```

```js
data: {
	sliderVal: 10
},
sliderChange: function(e) {
    this.setData({
        sliderVal: e.detail.value
    })
},
```

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210116185303955.png" alt="image-20210116185303955" style="zoom:50%;" />

### 8、switch

开关选择器

```html
<view>
    开关选择器
    <switch name="switch1" checked="{{switch_checked1}}" color="#987654" bindchange="switchChange" data-index="1"></switch>
    <switch name="switch2" checked="{{switch_checked2}}" type="checkbox" bindchange="switchChange" data-index="2"></switch>
    <switch disabled="true"></switch>
</view>
```

```js
data: {
	switch_checked1: true,
     switch_checked2: false
},
switchChange: function(e) {
    if(e.target.dataset.index === 1) {
        this.setData({
            switch_checked1: e.detail.value
        })
    } else {
        this.setData({
            switch_checked2: e.detail.value
        })
    }
}, 
```

## 七、小程序多媒体组件

### 1、audio音频

#### (1) 旧版audio

audio标签和web前端的HTML中的audio标签一样，用法接近，获取标签上下文有所差异

```html
<audio controls id="myAudio" src="{{audioSrc}}" poster="{{audioPoster}}" name="{{audioName}}" author="{{audioAuthor}}"></audio>
<button bindtap="audioPlay">播放</button>
<button bindtap="audioPause">暂停</button>
<button bindtap="audioJump">跳到1分钟处</button>
```

```js
data: {
    audioContent: null, // audio的上下文
    audioSrc: 'http://isure.stream.qqmusic.qq.com/C400000zFAcX3JhXzY.m4a?guid=7835168346&vkey=9F2A363BD0BDDE74C25C08A230007B65218C8C336D52283B3FBE0FEFD04B22639215900BA982A1C83AB31A1730A4B52294182E27B5A4026C&uin=1709&fromtag=66',
    audioPoster: 'https://y.gtimg.cn/music/photo_new/T002R300x300M000003V4tDF1O2xKF.jpg?max_age=2592000',
    audioAuthor: '伊格赛听 / 叶里',
    audioName: '谪仙'
},
audioPlay: function() {
    this.data.audioContent.play()
    this.data.audioContent.obeyMuteSwitch = false // 解决小程序中音频播放时没声音
},
audioPause: function() {
    this.data.audioContent.pause()
},
audioJump: function() {
    this.data.audioContent.seek(60)
},
onReady: function () {
    this.data.audioContent = wx.createAudioContext('myAudio') // 通过wx.createAudioContext(id)这种方式获取audio标签
},
```

由于小程序一打开页面就执行，而获取音频文件是一个异步操作，所以此时控制台会有报错信息

```js
[渲染层网络层错误]Failed to load media xxx(音频网址)
net::ERR_INSUFFICIENT_RESOURCES 
From server xxx.xxx.xxx.xxx
```

还没解决该问题

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210118153434662.png" alt="image-20210118153434662" style="zoom:50%;" />

#### (2) 新版audio

新版的audio不再需要标签，通过wx.createInnerAudioContext()获取一个实例，通过调用该实例上的属性或者方法就可以实现对音频播放的控制

```html
<button bindtap="audioPlay">播放</button>
<button bindtap="audioPause">暂停</button>
<button bindtap="audioJump">跳到1分钟处</button>
<button bindtap="audioVolumePlus">音量+</button>
<button bindtap="audioVolumeDrop">音量-</button>
```

```js
onShow: function () {
    this.innerAudioContext = wx.createInnerAudioContext()
    this.innerAudioContext.src = 'http://ws.stream.qqmusic.qq.com/C400003FBIxI0tdypN.m4a?guid=7835168346&vkey=D42695CC21AAABF692BCE6D23672E2AF9269195C5CAA41B0FEA0CE0EA3CA0489DC98E50401532ACF63A5A3AFCF8BE634E9AB26D65D89956C&uin=0&fromtag=66'
},
audioPlay: function() {
    this.innerAudioContext.play()
},
audioPause: function() {
    this.innerAudioContext.pause()
},
audioJump: function() {
    this.innerAudioContext.seek(60)
},
audioVolumePlus: function() {
    if(this.innerAudioContext.volume === 1) {
        console.log('当前音量已经满格了')
    } else if(this.innerAudioContext.volume >= 0.8) {
        console.log('如果继续调大音量可能会伤害耳朵')
        this.innerAudioContext.volume += 0.05
    } else {
        this.innerAudioContext.volume += 0.05
    }
},
audioVolumeDrop: function() {
    if(this.innerAudioContext.volume === 0) {
        console.log('当前已是静音状态')
    } else if(this.innerAudioContext.volume < 0.1) {
        console.log('如果继续调小音量，您可能会听不到声音')
        this.innerAudioContext.volume -= 0.05
    } else {
        this.innerAudioContext.volume -= 0.05
    }
},
```

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119182724361.png" alt="image-20210119182724361" style="zoom:50%;" />

### 2、video视频

和audio类似，用法和HTML中的video标签接近，获取标签的方式有差异

````html
<video controls id="myVideo" src="{{videoSrc}}" poster="{{videoPoster}}" title="{{videoName}}"></video>
<button bindtap="videoPlay">播放</button>
<button bindtap="videoPause">暂停</button>
````

```js
data: {
    videoContent: null, // video的上下文
    videoSrc: 'https://www.w3school.com.cn/i/movie.ogg',
    videoPoster: 'http://i0.hdslb.com/bfs/archive/061815692b330d27ba3dda9295a6627b2e420e2a.jpg@380w_240h_100Q_1c.webp',
    videoName: '女人不要乱动男人的东西'
},
videoPlay: function() {
    this.data.videoContent.play()
},
videoPause: function() {
    this.data.videoContent.pause()
},
onReady: function () {
    this.data.videoContent = wx.createVideoContext('myVideo')
}
```

### 3、image图片

和HTML中的img标签用法一样，属性中有一个lazy-load，默认是false，图片懒加载，在即将进入一定范围（上下三屏）时才开始加载

### 4、camera相机

系统相机。扫码二维码功能，用的比较少，具体见官网：https://developers.weixin.qq.com/miniprogram/dev/component/camera.html

## 八、canvas画布

### 旧版canvas

canvas画布与HTML5的canvas用法类似

```html
<canvas canvas-id="myCanvas" style="width: 620rpx; height: 620rpx; background-color: #65ed56"></canvas>
```

```js
onReady: function () {
	var myCanvas = wx.createCanvasContext('myCanvas')
    myCanvas.setStrokeStyle('#4a95dc') // 指定线条颜色
    myCanvas.setLineWidth(2) // 指定线条宽度
    myCanvas.arc(130, 130, 120, 0, 2*Math.PI, false) // 画圆
    myCanvas.moveTo(110, 100) // 画左眼
    myCanvas.arc(80, 100, 30, 0, Math.PI, true)
    myCanvas.moveTo(210, 100) // 画右眼
    myCanvas.arc(180, 100, 30, 0, Math.PI, true)
    myCanvas.moveTo(100, 130) // 画鼻子
    myCanvas.lineTo(160, 130)
    myCanvas.lineTo(130, 155)
    myCanvas.closePath()
    myCanvas.moveTo(80, 180) // 画嘴巴
    myCanvas.lineTo(180, 180)
    myCanvas.moveTo(80, 180)
    myCanvas.arc(130, 180, 50, 0, Math.PI, false)
    // 画牙齿
    myCanvas.moveTo(90, 180)
    myCanvas.lineTo(90, 210)
    myCanvas.moveTo(100, 180)
    myCanvas.lineTo(100, 220)
    myCanvas.moveTo(110, 180)
    myCanvas.lineTo(110, 225)
    myCanvas.moveTo(120, 180)
    myCanvas.lineTo(120, 230)
    myCanvas.moveTo(130, 180)
    myCanvas.lineTo(130, 231)
    myCanvas.moveTo(140, 180)
    myCanvas.lineTo(140, 230)
    myCanvas.moveTo(150, 180)
    myCanvas.lineTo(150, 225)
    myCanvas.moveTo(160, 180)
    myCanvas.lineTo(160, 220)
    myCanvas.moveTo(170, 180)
    myCanvas.lineTo(170, 210)
    myCanvas.stroke()
    myCanvas.draw()
}
```

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210118172340925.png" alt="image-20210118172340925" style="zoom:50%;" />

### 新版的canvas

有点坑，为图形填充颜色，官方文档给的是：

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119184752607.png" alt="image-20210119184752607" style="zoom:50%;" />![image-20210119184952291](D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119184952291.png)

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119185010631.png" alt="image-20210119185010631" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119184819214.png" alt="image-20210119184819214" style="zoom:50%;" />

按照官方文档的说法，这么写应该不会错：`ctx.fillStyle('red')`，但是实际上是这样的：

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119185103311.png" alt="image-20210119185103311" style="zoom:50%;" />

正确的写法是这样的：`ctx.fillStyle = 'red'`

如果是自己绘制的多边形，最后需要加一个`ctx.fill()`，将当前路径闭合，不然设置fillStyle不生效

```html
<canvas id="myCanvas2" type="2d"></canvas>
```

```js
onReady: function () {
	const query = wx.createSelectorQuery()
	query.select('#myCanvas2')
        .fields({ node: true, size: true })
        .exec((res) => {
        const canvas = res[0].node
        const ctx = canvas.getContext('2d')

        const dpr = wx.getSystemInfoSync().pixelRatio
        canvas.width = res[0].width * dpr
        canvas.height = res[0].height * dpr
        ctx.scale(dpr, dpr)

        ctx.fillStyle = 'red'
        ctx.moveTo(10, 100)
        ctx.lineTo(55, 0)
        ctx.lineTo(100, 100)
        ctx.lineTo(10, 40)
        ctx.lineTo(100, 40)
        ctx.lineTo(10, 100)
        ctx.fill()
        ctx.stroke()
    })
}
```

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119194132111.png" alt="image-20210119194132111" style="zoom:50%;" />



## 九、视图容器

### 1、swiper

滑块视图容器，类似于我们所做的轮播图，常用的属性有如下几个：

autoplay：自动轮播，默认为false

interval：自动切换时间间隔，默认时长5000ms，即5s

duration：滑动动画时长，默认500ms

indicator-dots：是否显示面板指示点，默认为false

indicator-color：指示点颜色，默认是rgba(0, 0, 0, .3)

indicator-active-color：当前选中的指示点颜色，默认是\#000000

circular：是否采用衔接滑动，默认是false

```html
<swiper class="swiper" autoplay="true" interval="2000" duration="1000" indicator-dots="true" indicator-color="#4a95dc" indicator-active-color="blueviolet">
    <block wx:for="{{imgSrcs}}" wx:for-item="img" wx:key="index">
        <swiper-item>
            <image src="{{img}}" class="pic"></image>
        </swiper-item>
    </block>
</swiper>
```

### 2、scroll-view

可滚动视图区域，与swiper不同的是，swiper所实现的轮播是一张图片一张图片滑动的，而scroll-view是可以一点点滑动的，常见的属性有如下几个：

scroll-x：允许横向滚动，默认是false；设置为横向滚动记得在scroll-view标签上加上样式：`display: flex; white-space: nowrap;`

scroll-y：允许纵向滚动，默认是false；设置为竖向滚动记得给scroll-view一个固定的高度

scroll-into-view：滚动(定位)到某个元素，值应为某子元素id(id不能以数字开头)，所以这个值应该是动态绑定的

bindscrolltolower：滚动到底部或者右边时触发，可以用于**上拉刷新 / 加载更多**，上拉刷新还可以使用页面自带的函数onReachBottom；

bindscrolltoupper：滚动到顶部或者左边时触发，可以用于**下拉刷新**

**注意**：scroll-view与页面中的onPullDownRefresh(监听用户下拉操作)冲突，当使用scroll-view标签时，onPullDownRefresh无效。如想要使用onPullDownRefresh，需要在页面对应的json文件中添加`enablePullDownRefresh: true`

```html
<scroll-view scroll-x="true" class="scroll-x" scroll-into-view="{{viewImg}}">
    <block wx:for="{{imgSrcs}}" wx:for-item="img" wx:key="index">
        <image src="{{img}}" id="{{'img'+index}}"></image>
    </block>
</scroll-view>
<button bindtap="scrollNext">下一个图</button>
<scroll-view scroll-y="true" class="scroll-y" scroll-into-view="{{viewImg}}">
    <block wx:for="{{imgSrcs}}" wx:for-item="img" wx:key="index">
        <image src="{{img}}" id="{{'img'+index}}"></image>
    </block>
</scroll-view>
```

```css
.scroll-x {
    display: flex;
    white-space: nowrap;
}
.scroll-y {
    height: 700rpx;
}
```

```js
data: {
    imgSrcs: [
        '../../images/5块钱如何活三天.jpg',
        '../../images/duck不必.jpg',
        '../../images/勾引.png',
        '../../images/呵，男人.jpg',
        '../../images/抱紧你.jpg'
    ],
    viewImg: 'img0'
},
scrollNext: function() {
    var index = this.data.viewImg.charAt(this.data.viewImg.length-1)
    var img = ''
    if(parseInt(index) === this.data.imgSrcs.length-1) {
        img = 'img0'
    } else {
        img = 'img' + (parseInt(index) + 1)
    }
    this.setData({
        viewImg: img
    })
},
```

用scroll-view做一个简单的导航菜单

```css
.scroll-top-nav {
    position: fixed;
    left: 0;
    top: 0;
    height: 80rpx;
    line-height: 80rpx;
    width: 100%;
    overflow: hidden;
    white-space: nowrap;
}
.scroll-top-nav .nav-item {
    font-size: 32rpx;
    display: inline-block;
    width: 20%;
    text-align: center;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
.scroll-top-nav .active {
    color: #4a95dc;
}
```

```html
<scroll-view scroll-x="true" class="scroll-top-nav" scroll-left="{{scrollLeft}}">
    <block wx:for="{{navList}}" wx:for-item="course" wx:key="id">
        <view 
            class="nav-item {{curNav === index?'active':''}}"
            bindtap="selectNav" data-cur="{{index}}">
            {{course.text}}
        </view>
    </block>
</scroll-view>
```

```js
data: {
    navList: [
        {
            id: 'all',
            text: '全部'
        },
        {
            id: 'html',
            text: 'HTML'
        },
        {
            id: 'css',
            text: 'CSS'
        },
        {
            id: 'js',
            text: 'JavaScript'
        },
        {
            id: 'vue',
            text: 'VUE'
        },
        {
            id: 'xcx',
            text: '小程序'
        },
        {
            id: 'node',
            text: 'nodejs'
        },
        {
            id: 'elementUI',
            text: 'elementUI'
        },
        {
            id: 'boostrap',
            text: 'boostrap'
        },
        {
            id: 'Vant',
            text: 'Vant Weapp'
        }
    ],
    curNav: 0,
    scrollLeft: 0
},
selectNav: function(e) {
    var cur = e.currentTarget.dataset.cur
    // 当我们点击菜单栏某一子项时，该子项自动居中
    // 由于设置了子项宽度为20%，所以每一个子项的宽度(singleNav)为屏幕宽度除以5
    var singleNav = this.data.screenWidth / 5
    this.setData({
        scrollLeft: (cur - 2)*singleNav
    })
    if(this.data.curNav !== cur) {
        this.setData({
            curNav: cur
        })
    }
},
onLoad: function (options) {
    wx.getSystemInfo({
        success: (result) => {
            this.setData({
                screenWidth: result.windowWidth // 获取屏幕宽度
            })
        },
    })
},

```

### 3、cover-view / cover-image

覆盖在原生组件之上的文本 / 图片视图，可以用作水印。

可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher

只支持**嵌套** cover-view、over-image，可在 cover-view 中使用 button。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。

```css
.video {
    width: 100%;
}
.video .shuiyin {
    color: cornflowerblue;
    font-size: 18px;
    text-align: center;
}
.video .shuiyin .img {
    width: 50%;
    display: block;
    margin-left: 25%;
}
```

```html
<video class="video" src="https://www.w3school.com.cn/i/movie.ogg" controls>
    <cover-view class="shuiyin">
        我孙某人
        <cover-image class="img" src="../../images/勾引.png"></cover-image>
    </cover-view>
</video>
```

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210119233847334.png" alt="image-20210119233847334" style="zoom:50%;" />

## 十、小程序页面跳转

### 1、navigator

页面链接，类似于HTML中的a标签，常用的属性有如下2个：

① url：当前小程序内的跳转链接，其值为某个页面的地址

② open-type：跳转方式，默认为navigate；

​	**navigate**：跳转到另一个页面时仍保持原来的页面，小程序左上角有`<`返回标志，页面栈最多保存10个，即最多只能跳转十层页面；无法跳转到底部导航栏的页面

​	**switchTab**：用来跳转底部导航栏的，会关闭其他所有非tabBar页面

​	**redirect**：跳转到另一个页面，但不保留原来的页面；

​	**reLaunch**：关闭页面栈中的所有页面并跳转到指定页面，小程序左上角没有返回标志

​	**navigateBack**：不需要指明页面地址，返回上一个页面或多个上级页面

**举个栗子**：

页面A以**navigate**方式跳转到页面B，再从页面B以**navigate**方式跳转到页面C，此时页面A、B都在页面栈中，小程序左上角有返回标志，点击时跳转回页面B，再点击一次返回页面A

页面A以**navigate**方式跳转到页面B，再从页面B以**redirect**方式跳转到页面C，此时页面B已被关闭，但小程序左上角有返回标志，点击时跳转回页面A

页面A以**navigate**方式跳转到页面B，再从页面B以**reLaunch**方式跳转到页面C，此时页面A、B都已被关闭，小程序左上角没有返回标志

```html
<!-- 不需要js，纯标签进行跳转 -->
<navigator url="/pages/demo4/demo4">跳转到demo4--swiper、scroll-view</navigator>
<navigator url="/pages/demo3/demo3">跳转到demo3--audio、video</navigator>
<navigator url="/pages/demo2/demo2">跳转到demo2--form表单</navigator>
<navigator url="/pages/demo/demo">跳转到demo</navigator>
```

### 2、路由跳转方法

使用普通的标签，通过给标签绑定点击(或其他)事件，触发改变路由的方法进行页面跳转。

① wx.navigatorTo()				

② wx.switchTab()：没有events属性		③ wx.relaunch()：没有events属性		④ wx.redirectTo()：没有events属性				

⑤ wx.navigatorBack()：没有events属性，有delta属性，返回的页面数，如果 delta 大于现有页面数，则返回到首页。

| 属性     | 类型     | 默认值 | 必填 | 说明                                                         |
| :------- | :------- | :----- | :--- | :----------------------------------------------------------- |
| url      | string   |        | 是   | 需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 `?` 分隔，参数键与参数值用 `=` 相连，不同参数用 `&` 分隔；如 'path?key=value&key2=value2' |
| events   | Object   |        | 否   | 页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持。 |
| success  | function |        | 否   | 接口调用成功的回调函数                                       |
| fail     | function |        | 否   | 接口调用失败的回调函数                                       |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）             |

```html
<view bindtap="jumpTo">以路由跳转的方式跳转到demo4</view>
```

```js
jumpTo: function() {
    wx.navigateTo({
        url: '/pages/demo4/demo4',
        success: function() {
            console.log('跳转成功')
        }
    })
},
```

#### 路由传参

路由传参需要在url地址后面加上？，？后面就是参数，形式为key = value，如果参数是两个或者两个以上，则以&隔开

**举个栗子**

页面A向页面B传两个参数：key1 = value1、key2 = value2

方法1：页面A通过navigator标签传参，页面B通过onLoad钩子函数接收

```html
<!-- 页面A的代码 -->
<navigator url="/pages/pageA/pageA?key1=value1&key2=value2">跳转到pageB</navigator>
```

```js
// 页面B的onLoad钩子函数
onLoad: function (options) {
    console.log(options.key1) // value1
    console.log(options.key2) // value2
},
```

方法2：页面A通过路由跳转方法传值，页面B依旧使用onLoad钩子函数接收

```html
<!-- 页面A的代码 -->
<view bindtap="jumpToB">跳转到pageB</view>
```

```js
// 页面A的jumpToB方法
jumpToB: function() {
    wx.navigateTo({
        url: '/pages/pageA/pageA?key1=value1&key2=value2',
        success: function() {
            console.log('跳转成功')
        }
    })
},
```

## 十一、小程序底部导航栏

小程序底部导航栏的实现，需要在app.json文件中加入tabBar选项

```json
{
    "tabBar": {
        "color": "#2b333b", // 导航栏字体颜色
        "selectedColor": "#4a95dc", // 选中时导航栏字体颜色
        "list": [
            {
                "pagePath": "pages/navDemo/navDemo", // 导航栏对应的页面
                "text": "首页", // 导航栏字体
                "iconPath": "images/icon.png", // 未选中时的图标
                "selectedIconPath": "images/selectedIcon.png" // 选中时导航栏的图标
                
            },
            {
                "pagePath": "pages/infoTab/infoTabBar",
                "text": "消息",
                "iconPath": "images/icon.png",
                "selectedIconPath": "images/selectedIcon.png"
            },
            {
                "pagePath": "pages/personal/personal",
                "text": "个人",
                "iconPath": "images/icon.png",
                "selectedIconPath": "images/selectedIcon.png"
            }
        ]
    },
}
```

**注意**：导航栏的图标只支持jpg、png、jpeg格式，不支持svg，所以需要未选中时的图标和选中时的图标；导航栏的排列顺序是按照list的元素顺序排列的

**tabBar**属性

| 属性       | 类型          | 默认值 | 必填 | 说明                                                         |
| :--------- | :------------ | :----- | :--- | :----------------------------------------------------------- |
| ext-class  | string        |        | 否   | 添加在组件内部结构的class，可用于修改组件内部的样式          |
| list       | array<object> |        | 否   | Tabbar的项的数组，按照规范，至少要有2个Tabbar项              |
| current    | number        | 0      | 否   | 当前选中的Tabbar项的下标                                     |
| bindchange | eventhandler  |        | 否   | Tabbar项发生改变的时候触发此事件，detail为{index, item}，index是Tabbar下标，item是对应的Tabbar项的配置 |

**list**属性是对象数组，每一项表示一个Tabbar项，其字段含义为

| 字段名           | 类型   | 默认值 | 必填 | 说明                                                         |
| :--------------- | :----- | :----- | :--- | :----------------------------------------------------------- |
| text             | string |        | 是   | Tabbar项的标题                                               |
| iconPath         | string |        | 否   | Tabbar项的icon图片路径，建议使用绝对路径，相对路径要相对于组件所在目录的。 |
| selectedIconPath | string |        | 否   | Tabbar项选中时的icon，建议使用绝对路径，相对路径要相对于组件所在目录的。 |
| badge            | string |        | 否   | 是否显示Tabbar的右上角的Badge                                |

## 十二、require函数

小程序可以在js文件中使用require函数引入其他有export的模块。

**举个栗子**

在utils文件夹中有一个名为util.js的文件，代码如下：

```js
const addFn = (num1, num2) => {
  return num1 + num2
}

const reduce = (num1, num2) => {
  return num1 - num2
}

module.exports = {
  add: addFn,
  reduce // 这种写法是：reduce: reduce的简写
}
```

在某个需要用到addFn / reduce方法的js文件中：

```js
var util = require('../../utils/util')
onReady: function () {
    var add = util.add(1, 2)
    var reduce = util.reduce(2, 1) 
    console.log(add) // 3
    console.log(reduce) // 1
},
```

## 十三、小程序模板化编程

小程序暂时不支持js文件模板化，只支持wxml文件和wxss文件提出来作为一个模板

首先新建一个文件夹来存放模板，文件夹下有一个wxml文件和一个wxss文件，其中wxss文件和其他页面的文件没区别，

wxml文件中代码用template标签包裹住，同时需要给template标签一个name属性，在需要引入模板的页面中，使用import标签的src属性将模板引入，然后使用template标签上的is属性指定引入模板中的某一个模板，通过data属性将值传给模板；引入css模板可以在wxss文件使用@import 'css文件地址'进行引入

```html
<!-- 这个是index.wxml -->
<template name="picture">
    <view class="item-content">
        <view class="img">
            <image src="{{item.src}}"></image>
        </view>
        <view class="img-info">
            <view class="title">表情包名称(template-name为picture)</view>
            <view class="name">{{item.name}}</view>
        </view>
    </view>
</template>
<template name="picture2">
    <view class="item-content">
        <view class="img">
            <image src="{{item.src}}"></image>
        </view>
        <view class="img-info">
            <view class="title">表情包名称(template-name为picture2)</view>
            <view class="name">{{item.name}}</view>
        </view>
    </view>
</template>
```

```css
/** 这个是index.wxss */
.img-list {
    height: 150px;
    width: 100%;
    overflow: scroll;
}
.img-list .img-item {
    width: 100%;
    margin: 2px;
    background-color: cornflowerblue;
    padding: 5px;
}
.img-list .img-item .item-content {
    display: flex;
    height: 40px;
    padding-left: 5px;
}
.img-list .img-item .img image {
    width: 40px;
    height: 40px;
    border-radius: 8px;
}
.img-list .img-item .img-info {
    margin-left: 10px;
    font-size: 12px;
    line-height: 20px;
}
.img-list .img-item .img-info .name {
    color: darkmagenta;
}
```

```html
<!-- 这个是需要引入模板的wxml文件 -->
<!-- 引入模板 -->
<import src="../../template/index.wxml"></import>
<view class="img-list">
    <view class="img-item" wx:for="{{imgList}}" wx:key="src">
        <template is="picture2" data="{{item}}"></template>
    </view>
</view>
```

```css
/* 这个是需要引入模板样式的wxss文件 */
@import '../../template/index.wxss'
```

## 十四、wxs模块

wxs模块有两种写法，一种是直接写在wxml文件中，用wxs标签包裹起来，一种是从外部引入；

wxs里面是写js代码用的，与HTML中的script标签类似，但是wxs只支持es5的语法，es6的语法是不支持的(即声明变量不能使用const、let等等)；文件末尾需要使用module.export将变量或者方法函数暴露出去。

wxs标签记得要添加一个module属性，指明这个模块的名称；

在wxs代码中没有new Date()这个方法，获取当前时间需要使用getDate()方法

方法① ：写在wxml文件中

```html
<wxs module="calculate">
    var add = function(num1, num2) {
        return num1 + num2
    }
    var jian = function(num1, num2) {
        return num1 - num2
    }
    var chengFn = function(num1, num2) {
        return num1 * num2
    }
    var chuFn = function(num1, num2) {
        return num1 / num2
    }
    module.exports = {
        jia: add,
        jian: jian, // 这里不能简写为：jian,
        cheng: chengFn,
        chu: chuFn
    }
</wxs>
<view>
    1+1={{calculate.jia(1,1)}}，
    2-1={{calculate.jian(2,1)}}，
    3*2={{calculate.cheng(3,2)}}，
    4/3={{calculate.chu(4,3)}}
</view>
```

方法② ：写在wxs文件中，新建一个文件夹用来存放wxs文件

```js
// wxs文件的代码
var add = function(num1, num2) {
    return num1 + num2
}
var jian = function(num1, num2) {
    return num1 - num2
}
var chengFn = function(num1, num2) {
    return num1 * num2
}
var chuFn = function(num1, num2) {
    return num1 / num2
}
module.exports = {
    jia: add,
    jian: jian,
    cheng: chengFn,
    chu: chuFn
}
```

```html
<!-- 需要引入wxs文件的wxml文件 -->
<wxs src="../../wxs/calculate.wxs" module="jisuan"></wxs>
<view>
    1+1={{jisuan.jia(1,1)}}，
    2-1={{jisuan.jian(2,1)}}，
    3*2={{jisuan.cheng(3,2)}}，
    4/3={{jisuan.chu(4,3)}}
</view>
```

## 十五、数据本地缓存

### 1、setStorage()

wx.setStorage()，将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。

| 属性     | 类型     | 默认值 | 必填 | 说明                                                         |
| :------- | :------- | :----- | :--- | :----------------------------------------------------------- |
| key      | string   |        | 是   | 本地缓存中指定的 key                                         |
| data     | any      |        | 是   | 需要存储的内容。只支持原生类型、Date、及能够通过`JSON.stringify`序列化的对象。 |
| success  | function |        | 否   | 接口调用成功的回调函数                                       |
| fail     | function |        | 否   | 接口调用失败的回调函数                                       |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）             |

```js
wx.setStorage({
  data: 'data',
  key: 'key',
  success: ()=> {
    console.log('成功回调')
  }
})
```

### 2、setStorageSync()

wx.setStorageSync(string key, any data)，是setStorage的同步缓存版本，其中any data只支持原生类型、Date、及能够通过`JSON.stringify`序列化的对象。

### 3、removeStorage()

wx.removeStorage()，从本地缓存中移除指定 key。

| 属性     | 类型     | 默认值 | 必填 | 说明                                             |
| :------- | :------- | :----- | :--- | :----------------------------------------------- |
| key      | string   |        | 是   | 本地缓存中指定的 key                             |
| success  | function |        | 否   | 接口调用成功的回调函数                           |
| fail     | function |        | 否   | 接口调用失败的回调函数                           |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

```js
// 用法1
wx.removeStorage({
  key: 'key',
  success (res) {
    console.log(res)
  }
})
// 用法2
try {
  wx.removeStorageSync('key')
} catch (e) {
  // Do something when catch error
}
```

### 4、removeStorageSync()

wx.removeStorageSync()，wx.removeStorage()的同步版本

### 5、getStorage()

wx.getStorage(Object object)，从本地缓存中异步获取指定 key 的内容。

| 属性     | 类型     | 默认值 | 必填 | 说明                                             |
| :------- | :------- | :----- | :--- | :----------------------------------------------- |
| key      | string   |        | 是   | 本地缓存中指定的 key                             |
| success  | function |        | 否   | 接口调用成功的回调函数                           |
| fail     | function |        | 否   | 接口调用失败的回调函数                           |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

成功回调函数success的参数属性：

| 属性 | 类型 | 说明          |
| :--- | :--- | :------------ |
| data | any  | key对应的内容 |

```js
// 用法1
wx.getStorage({
  key: 'key',
  success (res) {
    console.log(res.data)
  }
})
// 用法2
try {
  var value = wx.getStorageSync('key')
  if (value) {
    // Do something with return value
  }
} catch (e) {
  // Do something when catch error
}
```

### 6、getStorageSync()

wx.getStorageSync(string key)，是getStorage()的同步版本。

### 7、getStorageInfo()

wx.getStorageInfo(Object object)，异步获取当前storage的相关信息

| 属性     | 类型     | 默认值 | 必填 | 说明                                             |
| :------- | :------- | :----- | :--- | :----------------------------------------------- |
| success  | function |        | 否   | 接口调用成功的回调函数                           |
| fail     | function |        | 否   | 接口调用失败的回调函数                           |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

成功回调函数success的参数属性

| 属性        | 类型           | 说明                        |
| :---------- | :------------- | :-------------------------- |
| keys        | Array.<string> | 当前 storage 中所有的 key   |
| currentSize | number         | 当前占用的空间大小, 单位 KB |
| limitSize   | number         | 限制的空间大小，单位 KB     |

```js
// 用法1
wx.getStorageInfo({
  success (res) {
    console.log(res.keys)
    console.log(res.currentSize)
    console.log(res.limitSize)
  }
})
// 用法2
try {
  const res = wx.getStorageInfoSync()
  console.log(res.keys)
  console.log(res.currentSize)
  console.log(res.limitSize)
} catch (e) {
  // Do something when catch error
}
```

### 8、getStorageInfoSync()

wx.getStorageInfoSync()，wx.getStorageInfo()的同步版本

### 9、clearStorage()

wx.clearStorage(Object object)，清理本地数据缓存

| 属性     | 类型     | 默认值 | 必填 | 说明                                             |
| :------- | :------- | :----- | :--- | :----------------------------------------------- |
| success  | function |        | 否   | 接口调用成功的回调函数                           |
| fail     | function |        | 否   | 接口调用失败的回调函数                           |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

```js
// 用法1
wx.clearStorage()
// 用法2
try {
  wx.clearStorageSync()
} catch(e) {
  // Do something when catch error
}
```

### 10、clearStorageSync()

wx.clearStorageSync()，是wx.clearStorage(Object object)的同步版本

## 十六、常用的api

### 1、改变页面标题文本及样式

```js
wx.setNavigationBarTitle({
	title: 'title'
})
wx.setNavigationBarColor({
	backgroundColor: '#ffffff', // 颜色仅支持#ffffff和#000000
	frontColor: '#000000'
})
```

### 2、页面标题显示/隐藏加载动画

```js
wx.showNavigationBarLoading()
wx.hideNavigationBarLoading()
```

### 3、获取收货地址

```js
wx.chooseAddress({
    success: (res) => {
        // res中有收货地址的全部信息
    }
})
```



## 十七、小程序自定义组件

新建一个目录，选择新建的目录并右击，选择新建component，会自动生成类似于page的四个文件，但是内容和page不同，在新建的component中的json文件，有一个属性component需要设置为true(新建组件时就已经自动设置好了的)，在需要引入该组件的页面/组件中，直接在该页面/组件的对应的json文件中添加usingComponents属性，该属性值是一个对象，key为组件名，value为需要引入的组件的地址。

若直接在app.json文件中使用usingComponent属性，则表示将该组件设置为全局组件，

wxml节点标签只能是小写字母，下划线或中划线的组合，不能有大写字母，这点与vue引入组件时很像。

**注意**：自定义组件不支持以wx-开头，不然会报错

*自定义组件和template的区别*

自定义组件一般用在业务逻辑比较复杂的场景，而template模板只有wxml文件和wxss文件，所以一般用在重复展示的场景，不需要复杂的业务逻辑的场景。

组件中对应的wxss文件，在使用选择器时尽可能使用class选择器，不推荐使用id选择器(#a)，属性选择器([a])，元素选择器(button)

修改组件或者页面中的默认样式为：

```css
:host {
    ......
}
```

### 组件样式

默认情况下组件样式不会影响页面的样式，如果想让组件中的样式影响到页面中的其他样式，可以通过组件中的js文件进行配置

```js
Component({
    options: {
        styleIsolation: 'isolated'
    }
})
```

styleIsolation的取值及意义

isolated：默认值，表示启动样式隔离，在自定义组件内外，使用class指定的样式将不会相互影响，即组件中的样式不会影响到引入该组件的组件或者页面的样式。

apply-share：表示页面中的wxss样式将会影响到组件中的样式，而组件中的样式不会影响到页面中的样式

share：表示页面中的wxss样式将会影响到组件中的样式，组件中的样式也会影响到页面中的样式

### 组件间的传值

#### 父组件向子组件传数据

```html
<!-- 传值的页面或者组件的HTML文件 -->
<!-- 将item变量传递给goods组件，变量item需要在data中声明，传给组件的数据不能有大写字母，需要用-隔开 -->
<goods goods-item="{{item}}"></goods>
```

```json
// 传值的页面或者组件的json文件
{
  "usingComponents": {
    "goods": "组件的地址"
  }
}
```

```html
<!-- goods组件HTML代码 -->
<view class="goods-item">
  <view class="goods-img">
    <image src="{{goodsItem.img}}"></image>
  </view>
  <view class="goods-info">
    <view class="goods-name">
      {{goodsItem.name}}
    </view>
    <view class="other-info">
      <view class="price">
        ￥{{goodsItem.price}}
      </view>
      <view class="blong-to">
        {{goodsItem.belongTo}}
      </view>
    </view>
  </view>
</view>
```

```js
// goods组件的js代码，通过properties来接收页面或者组件传过来的数据
Component({
  properties: {
    goodsItem: {
      type: Object,
      value: {
        img: '图片地址',
        name: 'xxxx',
        price: 0,
        belongTo: '管理员'
      }
    }
  }
}
```

#### 父组件向子组件传样式

```css
/* 在父组件中定义号一个样式 */
.belonger-style {
  color: blue;
}
```

```html
<!-- 传给子组件时不需要加花括号 -->
<goods belonger-style="belonger-style"></goods>
```

```js
// 子组件通过属性externalClasses对样式进行接收
Component({
    externalClasses: ['belonger-style']
})
```

```html
<!-- 子组件接收到样式后可以直接使用，使用时也不用加花括号 -->
<view class="belonger-style">
	belonger
</view>
```

#### 子组件向父组件传值

```html
<!-- 子组件的HTML代码 -->
<view class="search">
  <input class="input" placeholder="请输入关键字" type="text" bindinput="inputKeyword" />
  <button class="button" bindtap="search">搜索</button>
</view>
```

```js
// 子组件js代码，通过this.triggerEvent('指定事件名', '参数是一个对象', '第三个参数很少用到，主要用来指明改事件是否拥有捕获阶段(capturePhase)，是否冒泡(bubbles)，是否可以穿越组件边界(composed)，也是一个对象，值为Boolean')
// 与vue的子组件向父组件传值十分相似，vue是使用this.$emit()来进行传值
Component({
  data: {
    inputKeyword: ''
  },
  methods: {
    inputKeyword: function(e) {
      this.setData({
        inputKeyword: e.detail.value
      })
    },
    search: function() {
      this.triggerEvent('clickSearch', {
        searchKey: this.data.inputKeyword
      })
    }
  }
})

```

```html
<!-- 父组件的HTML代码：使用bind + 子组件中指定的事件名，来监听子组件传过来的事件 -->
<search bindclickSearch="search"></search>
```

```js
// 父组件的js代码，通过e.detail.xxx(xxx表示从子组件中传过来的某一个key)
search: function(e) {
  console.log('搜索的关键字为' + e.detail.searchKey)
},
```

#### 父组件调用子组件的数据或方法

父组件通过this.selectComponent('id选择器').data可以获取到子组件的data中的数据，通过this.selectComponent('id选择器').sonMethod可以调用子组件的方法(sonMethod为子组件中已定义的方法)

```js
// 子组件son的js文件
Component({
  data: {
    sonData: 0
  },
  methods: {
    sonMethod: function(num = 1) {
      this.setData({
        sonData: this.data.sonData + num
      })
    }
  }
})
```

```html
<!-- 父组件的HTML代码 -->
<son id="son"></son>
<button bindtap="getSonData">获取子组件的数据</button>
<button bindtap="runSonMethod">执行子组件的方法</button>
```

```js
// 父组件的js代码
// component/fatherComp/father.js
Component({
  methods: {
    getSonData: function() {
      console.log(this.selectComponent('#son').data.sonData)
    },
    runSonMethod: function() {
      this.selectComponent('#son').sonMethod()
    }
  }
})
```

### 组件的生命周期

组件的生命周期函数需要写在lifetimes属性中，如果写在外面是旧版本的写法；

```js
Component({
  lifetimes: {
    created: function() {
	  // DO SOMETHING
    },
    attached: function() {
	  // DO SOMETHING
    }
  },
  // 以下是旧版本的写法，可以兼容2.2.3及以下的版本
  created: function() {
	// DO SOMETHING
  },
  attached: function() {
    // DO SOMETHING
  }
})
```

组件的生命周期函数有5个：比较重要的生命周期有created、attached、detached

**created**：组件实例被创建时触发，此时还不能调用setData()；

**attached**：组件添加到页面时触发，数据的赋值，初始化工作绝大多数是在这个生命周期完成；

**ready**：组件渲染完成时触发；

**moved**：组件从一个节点移到另一个节点时触发；(这个生命周期函数很少使用到)

**detached**：组件移除时触发，如组件上的v-if条件从true变成false，或者切离页面时，组件还在页面上。

### 组件监听页面的生命周期

组件可以通过pageLifetimes来监听其所在页面的生命周期，但是只能监听页面的两个生命周期函数还有一个窗口变化函数：show、hide、resize

**show**：页面显示时触发；

**hide**：页面隐藏(切到后台)或者退出时触发；

**resize**：当组件所在页面窗口尺寸发生变化时触发

## 十八、组件的数据监听器

组件的数据监听是通过observers属性对data中的字段进行监听，原理是通过监听this.setData()，所以在observers中不要使用this.setData()避免进入死循环。

```js
Component({
  data: {
    num: 0,
    a: 1,
    b: 2,
    obj: {
      age: 18,
      name: 'zhangsan'
    },
    arr: [0, 1, 2, 3, 4]
  },
  observers: {
    // 每次触发addOne函数时，num的值就会被监听，就会触发对应的函数，无论num是否会发生变化，即使函数是这样的：
    // this.setData({
    //    num: this.data.num
    // })
    // 即每次触发addOne函数，即使num值不变，也会触发observers
    'num': function(newVal) {
      console.log(newVal)
    },
    // 监听的形式还能这么写，同时监听多个变量，用逗号隔开，function中的每一个参数都对应着监听的字段的新值
     'a, b': function(newA, newB) {
         console.log(newA, newB)
     },
    // 当对象obj中的某个字段发生变化时会触发，执行ageAdd使得obj中age字段的值+1，
    // 当对象obj的结构发生变化时也会触发，执行ageAttr使得obj新增一个字段，此时会触发这个函数，打印what+undefined
    // 当obj的其他字段值发生变化时也会触发，执行changeName使得obj中name字段的值发生变化，打印what+undefined
    'obj.age': function(val) {
      console.log('what+' + val)
    },
    // 当数组第一个元素改变时触发，执行changeArr0使得数组第一个元素变化，会触发该函数
    // 当数组其他元素改变时也会触发，执行changeArrOther，使得数组其他元素变化，都会触发该函数
    // 当数组增加或删除元素时也会触发，执行pushEl或者popEl都会触发该函数
    'arr[0]': function() {
      var arrStr = ''
      for(var i = 0; i < this.data.arr.length; i++) {
        arrStr += '--' + this.data.arr[i]
      }
      console.log(arrStr)
    }
  },
  methods: {
    addOne: function() {
      this.setData({
        num: this.data.num + 1
      })
    },
    ageAdd: function() {
      this.setData({
        obj: {
          age: this.data.obj.age + 1
        }
      })
    },
    ageAttr: function() {
      this.setData({
        obj: {
          addr: 'xxxx'
        }
      })
    },
    changeName: function() {
      this.setData({
        obj: {
          name: 'sgs'
        }
      })
    },
    changeArr0: function() {
      this.data.arr[0] = 'change'
      this.setData({
        arr: this.data.arr
      })
    },
    changeArrOther: function() {
      this.data.arr[2] = 'change'
      this.setData({
        arr: this.data.arr
      })
    },
    pushEl: function() {
      this.data.arr.push(5)
      this.setData({
        arr: this.data.arr
      })
    },
    popEl: function() {
      this.data.arr.pop()
      this.setData({
        arr: this.data.arr
      })
    }
  }
})

```

也可以使用通配符**来匹配所有字段，如：

```js
observers: {
    'obj.attr1.**': function() {
		// 对象obj下的attr1字段下的所有字段都将被监听
    },
    '**': function() {
		// 所有使用setData设置的字段都被监听
    }
}
```

## 十九、组件间公用代码behavior

小程序的公用代码Behavior与vue的mixins类似，将公用的代码提取出来，在需要用到的地方直接引入使用，避免代码冗余；

引入Behavior的组件，会将自身的各个属性，生命周期与Behavior中的属性，生命周期进行合并；如果组件自身已经定义 的属性或者方法，与Behavior中定义的冲突，则优先使用自身的属性或方法；而生命周期函数则不会相互覆盖，而是先执行Behavior中的钩子函数，再执行组件中的钩子函数。

若同一个behavior被一个组件多次引用，它的生命周期只会执行一次；若一个组件引用多个behavior，后面的behavior属性或方法会覆盖前面的behavior的属性或者方法。

object参数的属性如下：

| 定义段     | 类型         | 是否必填 | 描述                  | 最低版本 |
| :--------- | :----------- | :------- | :-------------------- | :------- |
| properties | Object Map   | 否       | 同组件的属性          |          |
| data       | Object       | 否       | 同组件的数据          |          |
| methods    | Object       | 否       | 同自定义组件的方法    |          |
| behaviors  | String Array | 否       | 引入其它的 `behavior` |          |
| created    | Function     | 否       | 生命周期函数          |          |
| attached   | Function     | 否       | 生命周期函数          |          |
| ready      | Function     | 否       | 生命周期函数          |          |
| moved      | Function     | 否       | 生命周期函数          |          |
| detached   | Function     | 否       | 生命周期函数          |          |

举个栗子：组件myBehavior1和myBehavior2都需要接收一个name属性，同时还需要一个age变量，调用getData方法

首先新建一个js文件——behavior.js，代码如下：

```js
// 使用Behavior()创建一个实例，Behavior接收一个object参数
let myBehavior = Behavior({
  properties: {
    name: {
      type: String,
      value: 'behavior.js的默认值'
    }
  },
  data: {
    age: 18
  },
  methods: {
    getData: function() {
      console.log(this.data.age + '---' + this.data.name)
    }
  },
  lifetimes: {
    ready: function() {
      console.log('这是公用组件behavior.js的ready钩子函数')
    }
  }
})
module.exports = myBehavior
```

组件myBehavior1的js代码如下：

```js
var comm = require('../behavior.js')
Component({
  behaviors: [comm],
  lifetimes: {
    // 调用了behavior.js中生命周期函数ready的输出语句，同时调用了behavior.js中的getData()方法
    ready: function() {
      this.getData()
    }
  }
})
```

![image-20210208113449318](D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210208113449318.png)

组件myBehavior2的js代码如下：

```js
var comm = require('../behavior.js')
Component({
  behaviors: [comm],
  data: {
    // 由于自身有age字段，而behavior.js中的data也有age字段，所以优先使用自身的
    age: 25
  },
  methods: {
    getData: function() {
      console.log('这是组件自身的getData函数')
    }
  },
  lifetimes: {
    // 调用了behavior.js中生命周期函数ready的输出语句，同时调用了自身的getData()方法
    ready: function() {
      this.getData()
    }
  }
})
```

![image-20210208113548454](D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210208113548454.png)

## 二十、computed与watch的引入与使用

### 1、computed

小程序自身并没有computed属性，若想使用computed，需要引入computed的类库

执行`npm install --save miniprogram-computed`，下载相应类库，此时，在miniprogram_npm文件夹下多了一个miniprogram-computed文件夹

若下载包的过程中出现No repository field、No description，则在项目的package.json中的description字段添加一点描述(不添加也没事，可以不管)，然后再添加一个字段"private": true，这样就不会报错了

在需要用到computed属性的组件或者页面的js文件中，引入类库；

```js
const computedBehavior = require('miniprogram-computed')
Component({
  behaviors: [computedBehavior],
  data: {
    a: 1,
    b: 1,
  },
  computed: {
    sum(data) {
      // 注意： computed 函数中不能访问 this ，只有 data 对象可供访问
      // 这个函数的返回值会被设置到 this.data.sum 字段中
      return data.a + data.b
    }
  }
}) 
```

小程序的computed与vue中的computed类似，在computed中定义的变量不能与data中的变量冲突；

小程序的computed中不能使用this，接收的参数为data，为当前页面或者组件中的data数据

### 2、watch

小程序的watch与computed都是引入同一个类库，区别在于watch中监听的数据必须是已经声明的变量，而compted中监听的数据是未定义的变量

```js
const computedBehavior = require('miniprogram-computed')
Component({
  behaviors: [computedBehavior],
  data: {
    a: 1,
    b: 1,
    sum: 2,
  },
  watch: {
    'a, b': function(a, b) {
      this.setData({
        sum: a + b
      })
    },
  }
})
```

- 对于没有使用 `**` 通配符的字段，在 `watch` 检查值是否发生变化时，只会进行粗略的浅比较（使用 `===` ）；
- 对于使用了 `**` 通配符的字段，则会进行深比较，来尝试精确检测对象是否真的发生了变化，这要求对象字段不能包含循环（类似于 `JSON.stringify` ）。

### 3、应该使用 computed 还是 watch ？

从原理上说， `watch` 的性能比 `computed` 更好；但 `computed` 的用法更简洁干净。

此外， `computed` 字段状态只能依赖于 `data` 和其他 `computed` 字段，不能访问 `this` 。如果不可避免要访问 `this` ，则必须使用 `watch` 代替。

### 4、watch 和小程序基础库本身的 observers 有什么区别？

无论监听的字段是否真的改变，`observers` 都会被触发，而 `watch` 只在监听的字段的值改变了的时候触发，并且触发时带有参数。

## 番外之引入vant-weapp组件库

1、首先进入项目的根目录，新建的项目目录如下：

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210208155702377.png" alt="image-20210208155702377" style="zoom:50%;" />

2、命令行进入该项目根目录，使用命令：mpn init，初始化项目，生成package.json文件，不断回车，使用默认的即可

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210208160121359.png" alt="image-20210208160121359" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210208160231204.png" alt="image-20210208160231204" style="zoom:50%;" />

3、使用命令：`npm i @vant/weapp -S --production`下载组件库，目录中多了一个node_modules文件夹和一个package-lock.json文件

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210208161615656.png" alt="image-20210208161615656" style="zoom:50%;" />

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210208161636813.png" alt="image-20210208161636813" style="zoom:50%;" />

4、修改app.json文件，去掉里面的"style": "v2"

5、修改project.config.json，这个是重点，里面的miniprogramNpmDistDir是表示整个项目的目录，我的项目放在demo2文件夹中，所以miniprogramNpmDistDir的值我取"../demo2/"。

```json
{
    "setting": {
		"packNpmManually": true,
    	"packNpmRelationList": [
      		{
        		"packageJsonPath": "./package.json",
        		"miniprogramNpmDistDir": "../demo2/" // 这里需要注意一下，要是路径不对，会报错
      		}
    	],
    }
}
```

6、打开微信开发者工具，点击 **工具 -> 构建 npm**

7、点击**详情->本地设置**，并勾选 **使用 npm 模块** 选项

8、由于我在构建时出现npm入口文件找不到，所以我把node_modules文件夹下的@type文件夹删除，然后再次构建一下，构建成功，目录中又多了一个文件夹miniprogram_npm，这里面的文件就是我们需要的vant-weapp的组件

9、引入：在需要引入组件的页面或者组件的json文件中添加`"usingComponents": {  "自定义组件名": @vant/weapp/需要的组件/index" }`



















































