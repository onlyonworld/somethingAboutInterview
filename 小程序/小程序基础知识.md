# 小程序基础知识点

## 一、小程序项目的结构

### 1、pages

pages文件夹是小程序的页面，一个子文件夹代表一个页面；

一个子文件夹下默认有四个文件：js文件、json文件、wxml文件、wxss文件。

​	js文件：小程序页面的逻辑层

​	json文件：小程序页面的配置

​	wxml文件：小程序页面骨架，相当于web前端中的html文件

​	wxss文件：小程序页面样式，相当于web前端中的css文件

### 2、utils

utils文件夹可以用来存放小程序的公用方法，是一个工具文件，通过module.exports将方法导出，提供给其他页面使用

### 3、app.js

小程序主要逻辑层，用来注册小程序，一定要有。

通过App()这个方法注册小程序，在其他页面可以通过getApp()这个方法来获取应用实例。

举个栗子：

```js
// app.js文件代码
App({
    globalData: {
		userInfo: 'balabala'
    }
})
// 在其他页面的js文件中
const app = getApp()
// 通过 app.globalData.userInfo可以获取到app.js文件中的数据
```

### 4、app.json

小程序的公共配置，一定要有

```json
{
  // pages代表小程序页面路由，我们可以在这里配置页面，排在第一个的路由代表启动小程序时的初始页面
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  // window主要是用来配置窗口的信息及样式
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json" // 站点文件，主要写小程序的一些索引，方便微信搜索，提高曝光率
}
```

小程序页面中的json文件配置会覆盖掉这些公共的配置

### 5、app.wxss

小程序的公共样式，可有可无

小程序页面中的wxss文件配置会覆盖掉这些公共的样式

### 6、project.config.json

项目配置文件，新建项目时自动生成，自动写好，一般不需要去修改它

### 如何新建一个页面

首先，在pages文件夹下新建一个文件夹，用来表示需要新建的页面，鼠标右击新建的文件夹，选择新建Page，自动生成页面默认所需的四个文件

然后，在app.json文件中的pages添加新建页面的路径

## 二、小程序标签样式

### 标签

#### 1、view

小程序中没有div、span等标签，它的view标签就相当于web前端中的div标签

#### 2、text

### 样式

#### 1、自适应尺寸单位rpx

可以根据屏幕宽度自适应，规定屏幕宽度为750px

<img src="D:\GitHubRepository\小程序\小程序基础知识.assets\image-20210113154836616.png" alt="image-20210113154836616" style="zoom:50%;" />



## 三、小程序生命周期

### 1、onLaunch

监听小程序初始化

### 2、onShow

监听小程序启动或者切前台的操作

### 3、onHide

监听小程序切后台的操作

### 4、onError

错误监听函数，当小程序发生错误时触发

### 5、onPageNotFound

页面不存在监听函数，当页面不存在时触发

## 四、小程序页面的生命周期

### 1、onLoad

监听页面加载，当页面加载完成后触发

### 2、onShow

监听页面显示，当页面显示出来时触发

### 3、onReady

监听页面初次渲染完成，当页面渲染完成后触发

### 4、onHide

监听页面隐藏，切后台或者切换到其他页面均会触发这个函数

### 5、onUnload

监听页面卸载，关闭当前页面时触发

### **注意**

每个页面的onLoad、onReady函数只会触发一次，此后即使跳转到其他页面再跳转回来，也不会再次触发

## 五、小程序知识点

### 1、小程序没有DOM

小程序没有DOM概念，所以在js文件中无法使用document.getElementById()等等来获取页面中的DOM元素

### 2、数据绑定

小程序的数据绑定是单向数据绑定，使用{{}}进行数据绑定，这点与vue一样，但是vue是数据双向绑定；

### 3、数据赋值

```js
/* 在vue中 */
data() {
    str: 'jack',
    age: 18
}
// 改变data中的值
this.str = 'john' // 这样页面(视图)上数据也会跟着改变

/* 在小程序中 */
data: {
    str: 'jack',
    age: 18
}
// 改变data中的值
this.data.str = 'john' // 由于小程序是数据单向绑定，赋值之后页面数据并不会变化
this.setData(this.data) // 调用this.setData()，驱动视图更新
```

### 4、条件渲染

```html
<!-- 在vue中 -->
<div v-if="flag"></div>
<div v-else-if="flag"></div>
<div v-else></div>
<!-- 在小程序中 -->
<view wx:if="{{flag}}"></view>
<view wx:elif="{{flag}}"></view>
<view wx:else></view>
```

### 5、循环渲染

```html
<!-- 在vue中 -->
<div v-for="(item, index) in list" :key="item.id">
	......
</div>

<!-- 在小程序中 -->
<block wx:for="{{ list }}" wx:for-item="item" wx:key="id" wx:for-index="index">
	<!-- 
		可以使用block标签，也可以使用view标签；
		在小程序中使用循环渲染和vue有较大的区别，可以不声明wx:for-item和wx:for-index，然后直接使用item和index来表示列表的每一项和索引值，这个是默认的，可以不写出来，绑定key值时直接使用列表项中的唯一值，不需要像vue一样使用item.id
	-->
</block>
```

### 6、小程序事件

小程序在绑定事件时需要在事件前面加bind，以下事件都是冒泡事件

#### 6.1 tap

触摸后马上离开时触发，相当于点击事件

```html
<!-- 在vue中，v-on:可以缩写为@ -->
<button v-on:click="changeSomething()">点击按钮</button>
<button @click="changeSomething()">点击按钮</button>

<!-- 在小程序中，bind后面的:可以省略 -->
<button bind:tap="changeSomething">点击按钮</button>
<button bindtap="changeSomething">点击按钮</button>
```

#### 6.2 touchstart

手指触摸动作开始时触发

#### 6.3 touchmove

手指触摸后移动

#### 6.4 touchcancel

手指触摸动作被打断，如来电提醒，弹窗

#### 6.5 touchend

手指触摸动作结束

#### 6.6 longpress

手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发

#### 6.7 longtap

手指触摸后，超过350ms再离开(推荐使用longpress事件代替)

### 7、小程序中catch和bind的区别

bind会触发事件冒泡机制

catch会阻止事件冒泡

```html
<view bindtap="containerPrint">
    <text bindtap="textPrint">文本</text>
</view>

<view bindtap="containerPrint">
    <text catchtap="textPrint">文本</text>
</view>

<view catchtap="containerPrint">
    <text catchtap="textPrint">文本</text>
</view>
```

```js
containerPrint: function() {
	console.log("container")
},
textPrint: function() {
	console.log("text")
}
// 第一个view中，点击text文本时由于冒泡事件，会触发父元素上对应的事件
// 第二和第三个view中，点击text均不会触发父元素上的对应的事件
```

### 8、小程序事件冒泡与捕获

```html
<!-- 在小程序中，
	事件捕获阶段使用capture-bind，后面冒号不能省略；
	中断事件捕获阶段用capture-catch，但是同时冒泡事件也被取消了
-->
<view bindtap="containerTap" capture-bind:tap="captureTap">
	<text bindtap="txtTap" capture-bind:tap="captureTap2">小程序</text>
</view>
<!--
	当点击文本时，输出captureTap、captureTap2、text、container
    先是事件捕获阶段，触发父元素上的capture-bind:tap事件以及子元素上的capture-bind:tap事件
    然后是事件冒泡阶段，触发子元素上的bindtap事件以及父元素上的bindtap事件
-->
<view bindtap="containerTap" capture-bind:tap="captureTap">
	<text bindtap="txtTap" capture-catch:tap="captureTap2">小程序</text>
</view>
<!--
	当点击文本时，输出captureTap、captureTap2
    先是事件捕获阶段，触发父元素上的capture-bind:tap事件以及子元素上的capture-catch:tap事件
	但是子元素使用了中断事件捕获和取消事件冒泡的capture-catch:tap，导致后面的text、container没有输出
-->
```

```js
containerTap: function() {
	console.log("container")
},
captureTap: function() {
	console.log("captureTap")
},
txtTap: function() {
	console.log("text")
},
captureTap2: function() {
	console.log("captureTap2")
}
```









