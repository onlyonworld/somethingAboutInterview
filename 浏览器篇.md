### 1、什么是浏览器渲染(客户端渲染)？什么是服务器渲染

#### 客户端渲染

客户端渲染模式下，`html`仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，客户端拿到服务端发送过来的文件后执行一遍文件上的`JS文件`，根据`JS`运行结果，生成相应`DOM`并插入到`HTML`中，然后渲染给用户。

**优点**

后端只提供数据，前端做视图和交互逻辑，分工明确。服务器只提供接口，路由以及渲染都丢给前端，服务器计算压力变轻了。

**缺点**

用户等待时间变长了。

#### 服务器渲染

服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成`HTML`字符串，然后把它返回给客户端。客户端拿到服务端发送过来的数据，可以直接渲染，然后呈现给用户的`HTML`内容，不需要为了生成 `DOM `内容而去执行一遍` JS `代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找。

**优点**

响应很快，用户体验会比较好；对于搜索引擎来说也是友好的

**缺点**

增加了服务器计算压力

### 2、SessionStorag、localStorage、cookie和session的区别和优缺点

**区别**

三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。

SessionStorage和localStorage属于WebStorage，本地存储，存储在客户端

localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信

sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。

cookie和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。

cookie的有效期可以自己设置，如果没有自己设置一个有效期，那么当关闭当前页面或者关闭浏览器时cookie过期。由于cookie是保存在客户端，所以cookie不是很安全，黑客可以分析存放在本地的cookie，通过盗用伪造用户身份进行cookie欺骗。 cookie也分为永久和暂时存在的; 记住密码功能就是使用永久cookie写在客户端电脑，下次登录时，自动将cookie信息附加发送给服务端。

Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(longinterval)修改。由于session是保存在服务器上，每个用户都有一个独立的session，当有大量用户同时访问时会给服务器带来压力。浏览器页面一关闭，session也就失效了。

**优缺点**

cookie的优点：

具有极高的扩展性和可用性
通过良好的编程，控制保存在cookie中的session对象的大小
通过加密和安全传输技术，减少cookie被破解的可能性
只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失
控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie

cookie的缺点：

cookie的长度和数量的限制。每个cookie长度不能超过4KB，否则会被截掉。cookie会每次随http请求一起发送，浪费宽带。

localstorage优点：

可以大量保存浏览器中数据。不会随http请求一起发送

localstorage缺点：

不同窗口下数据；不能独立，相互干扰。

sessionstorage优点：

可以大量保存浏览器中数据。不同窗口下的sessionStorage，存储相互独立；互不干扰

sessionstorage缺点：

当页面关闭后，sessionStorage 中的数据就会被清空

### 3、cookie有哪些属性？浏览器如何禁止别人访问cookie

cookie的属性有：name(cookie的名称)、value(cookie的值)、domain(可以访问此cookie的域名)、path(以访问此cookie的页面路径)、Max-Age(字段为此cookie超时时间)、size(cookie大小)、http(cookie的httponly属性；若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie)、secure(设置是否只能通过https来传递此cookie)

通过设置浏览器的 Always send Do not Track header / 随浏览流量一起发送"不跟踪'请求 这一选项防止用户隐私被跟踪，保护用户网络隐私。	

### 4、从输入网址到获得页面的过程

#### （1）输入网址按回车键或点击跳转

#### （2）DNS域名解析，获取IP地址

在浏览器缓存、hosts文件、路由器缓存中查找url对应的IP地址。如果没有找到，则发起一个DNS请求到本地域名服务器，在其缓存中进行查找。如果没有，本地DNS服务器向根DNS服务器发起请求，根DNS服务器返回顶级DNS服务器的地址；本地DNS服务器向顶级DNS服务器发起请求，顶级DNS服务器返回权限DNS服务器的地址；本地DNS服务器向权限DNS服务器发起请求，权限DNS服务器查询到域名对应的IP后，将IP地址返回给本地DNS服务器；本地DNS服务器接收后将其保存到缓存中，以备下次查询。本地DNS服务器将IP地址返回给客户主机浏览器。

#### （3）浏览器向Web服务器发送HTTP请求

浏览器以一个随机的端口向服务器发起TCP连接请求。三次握手后，建立TCP连接。建立连接后，发送一个HTTP请求，包含请求行、请求头、请求正文

#### （4）服务器处理请求，返回HTTP响应

服务器接收到TCP报文后，对HTTP协议进行解析，然后将相应的数据封装为HTTP Request对象，供上层使用。HTTP响应，包括状态行、响应头、响应正文。

#### （5）浏览器下载web服务器返回的数据及解析htm|源文件

用户请求的HTML文档通过浏览器的网络层到达渲染引擎后，渲染工作开始。

### 5、从输入网址到网页渲染完成经历了什么

​	1）输入网址按回车键或点击跳转

​	2）发送到DNS服务器进行DNS解析，获取到我们对应web服务器对应的ip地址

​	3）与Web服务器建立TCP连接

​	4）浏览器向web服务器发送http请求

​	5）Web服务器进行响应请求并返回指定的url数据(当然这里也可能是错误信息或者重定向到信的urI地址等)

​	6）浏览器下载web服务器返回的数据及解析htm|源文件

​	7）根据文件生成DOM树和CSS规则树合成我们的渲染树，解析js，最后渲染我们的页面然后显示出来

### 6、浏览器的回流(重排)与重绘

涉及到浏览器渲染页面的过程，浏览器解析HTML生成DOM树，解析css生成css规则树，在DOM树和css规则树结合生成渲染树的过程中，需要计算每个节点的位置和大小，这个计算过程就是回流。在计算完节点的位置和大小后，需要将节点转换为屏幕中的实际像素，这个过程称为重绘。

**回流一定会引发重绘，重绘不一定会引起回流**

**何时发生回流重绘**

​	1）添加或者删除可见的DOM元素
​	2）元素的位置、尺寸发生变化
​	3）页面开始渲染的时候
​	4）浏览器的视口尺寸大小发生改变(因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小)

**如何避免发生回流重绘**

避免操作DOM操作

将需要多次回流的元素position属性设为absolute或fixed，这样该元素就会脱离文档流，它的变化不会影响其他元素变化。

避免使用`table`布局，一些很小的变化，会导致`table`中所有其他节点回流。

使用`visibility`替换`display: none`，因为前者只会引起重绘，后者会引发回流(改变了布局)

尽可能在`DOM`树的最末端改变`class`，回流是不可避免的，但可以减少其影响。尽可能在`DOM`树的最末端改变`class`，可以限制了回流的范围，使其影响尽可能少的节点。

### 7、前端`SEO`需要注意什么

（1）合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可。

（2）语义化的`HTML`代码，符合`W3C`规范：语义化代码让搜索引擎容易理解网页。

（3）重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。

（4）重要内容不要用`js`输出：爬虫不会执行`js`获取内容 

（5）少用`iframe`：搜索引擎不会抓取`iframe`中的内容 

（6）非装饰性图片必须加`alt `

### 8、移动端web页面适配方案

#### 8.1 百分比方案

使用 **百分比%** 定义 **宽度**，**高度** 用**`px`**固定，根据可视区域实时尺寸进行调整，尽可能适应各种分辨率，通常使用`max-width`/`min-width`控制尺寸范围过大或者过小。

##### 优势

原理简单，不存在兼容性问题

##### 不足

如果屏幕尺度跨度太大，相对设计稿过大或者过小的屏幕不能正常显示，在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化

#### 8.2 rem方案

**rem**是相对长度单位，rem方案中的样式设计为相对于**根元素**`font-size`计算值的倍数。根据 **屏幕宽度** 设置`html`标签的`font-size`，在布局时使用 **rem** 单位布局，达到自适应的目的，是 **弹性布局** 的一种实现方式。

##### 优势

兼容性好

##### 不足

不是纯css移动适配方案，需要引入js脚本，在头部内嵌一段 `js`脚本 **监听分辨率的变化来动态改变根元素的字体大小**，`css`样式和 `js` 代码有一定 **耦合性**，并且必须将改变`font-size`的代码放在 **css** 样式之前。

#### 8.3 vh/vw方案

用`vh(viewport height)`或者`vw(viewport width)`来表示元素的宽高。

**vw** : **1vw** 等于 **视口宽度** 的 **1%**

**vh** : **1vh** 等于 **视口高度** 的 **1% **

##### 优势

纯 **css** 移动端适配方案，不存在脚本依赖问题

相对于 **rem** 以**根元素字体大小的倍数** 定义 **元素大小**，逻辑清晰简单，视口单位依赖于视口的尺寸 `"1vw ＝ 1/100 viewport width"`，根据 **视口尺寸的百分比** 来定义 **元素宽度**

##### 不足

存在一些兼容性问题，Android4.4以下不支持

#### 8.4 基于媒体查询的响应式设计

**媒体查询**，通过给不同分辨率的设备编写不同的样式实现响应式布局，用于解决不同设备不同分辨率之间兼容问题，一般是指PC、平板、手机设备之间较大的分辨率差异。实现上不局限于具体的方案，通常结合了 **流式布局** `+` **弹性布局** 方案。

```css
@media only screen and (min-width: 375px){
    样式1
}
@media only screen and (min-width: 750){
    样式2
}
```

能够使网页在不同设备、不同分辨率屏幕上呈现合理布局，不仅仅是样式伸缩变换

##### 不足

要匹配足够多的设备与屏幕，一个web页面需要多个设计方案，工作量比较大

### 9、浏览器的缓存机制是什么

即**http缓存**