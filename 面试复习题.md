面试题

## 一、vue层面面试题

### 1、谈谈你对MVVM开发模式的理解

​	MVVM分为Model、View、ViewMode三者

​	■Model: 代表数据模型，数据和业务逻辑都是在Model层中定义

​	■View: 代表UI视图，负责对数据的展示

​	■ViewModel: 负责监听Model中数据的改变并控制视图的更新，处理用户交互操作

​	Model和View并无直接关联，而是通过ViewModel来进行联系的，ModeI和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。

​	这种模式实现了ModeI和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom.

### 2、对于组件通信你了解多少，请描述一下你是怎么完成组件的通信的

​	1）父组件向子组件传值，父组件通过数据绑定，子组件通过props进行接收

​	2）子组件向父组件传值，子组件通过this.$emit，传递一个事件还有需要传给父组件的值，父组件通过触发子组件传过来的事件，可以接收到子组件传过来的值

​	3）非父子之间的传值建立一个空实例进行传值，中央事件总线机制。例如建立一个bus.js空实例，在需要传值的组件中去触发

```js
//原理上就是建立一个公共的js文件， 专门用来传递消息
// bus.js 
import Vue from 'vue'
export default new Vue;

//在需要传递消息的地方引入
import bus from ' . /bus.js '

//传递消息
bus.$emit( 'msg', val) 

//接受消息
bus.$emit( 'msg', val => {
	console.log(val )
})

```

​	4）祖孙之间的传值

​		a.可以利用provide inject模式，在一个组件中通过provide 给孙子组件传值，孙子组件通过inject进行接收，这个模式是在vue2.5版本之后才开始有的

​		b.可以通过 $attrs 传值，借助中间组件的协助

```vue
<!--祖组件：通过属性绑定将值传给父组件，其中a、b、c为data中的数据-->
<parent :msga="a" :msgb="b" :msgc="c"></parent>
<!--父组件：通过v-bind="$attrs" (这个v-bind不能简写为:)，将祖组件的值传给子组件-->
<son v-bind="$attrs"></son>
<!--孙子组件：通过this.$attrs接收这些值-->
console.log(this.$attrs.msga) ;
```

VUEX可以处理上述的每一个情况，通过建立一个数据仓库，可以让数据共享到每一个组件

### 3、v-if和v-show的区别

1）v-if是动态的向DOM树内添加或者删除DOM元素，v-show是通过设置DOM元素的display样式属性控制显示或者隐藏

2）编译过程中，v-if是惰性的，如果一开始条件为false，则什么都不做，即不进行编译，到将其条件切换为true时，才进行编译，如果在变为true之后又切换为false，那么这时候需要进行局部卸载；而v-show则不管初始条件是否为true都进行编译，然后缓存起来，而且DOM元素被保留，所以v-if有更高的切换消耗，而v-show有更高的初始渲染消耗

### 4、关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理

​	1）将公用的JS库通过script标签在index.html进行外部引入，减少我们打包出来的js文件的大小，让浏览器并行下载资源文件，提高下载速度

​	2）在配置路由的时候进行路由的懒加载，在调用到该路由时再加载次路由相对应的js文件

​	3）加一个首屏loading图或骨架屏，提高用户的体验

​	4）尽可能使用CSS Sprites和字体图标库

​	5）图片的懒加载等

### 6、关于修改了数据，视图不更新的理解和处理方式

​	Vue中给data中的对象属性添加一个新的属性时会发生什么

​	经过打印发现数据是已经改变了，但是由于在Vue实例创建时，新添加的属性并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api  --> set()
​	$set()使用方法： $set(需要修改的对象, “对象的属性", 值)

注意：在$set()中对象属性需要双引号包起来

```html
<div id="app">
        <ul>
            <li v-for="(item, index) in obj" :key="index">{{item}}</li>
        </ul>
        <button @click="addAttr1">添加属性d</button>
        <button @click="addAttr2">添加属性e</button>
</div>
<script>
    var vm = new Vue({
       el:'#app',
       data:{
           obj: {
               'a': 'I am a',
               'b': 'I am b',
               'c': 'I am c'
           }
       },
       methods:{
           addAttr1(){
               this.obj.d = 'I am d'
               console.log(this.obj)
               /*
                   此时在页面打印出来的依旧只有：
                   I am a 
                   I am b
                   I am c
                   
                   而此时控制打印出来的有：
                   a: "I am a"
                   b: "I am b"
                   c: "I am c"
                   d: "I am d"  
               */
           },
           addAttr2(){
               this.$set(this.obj, 'e', 'I am e')
               console.log(this.obj)
               /*
                   此时在页面打印出来的依旧只有：
                   I am a 
                   I am b
                   I am c
                   I am e

                   而此时控制打印出来的有：
                   a: "I am a"
                   b: "I am b"
                   c: "I am c"
                   e: "I am e"  
               */
           }
       }
    });
</script>
```

### 7、在Vue中如何做数据的监听

​	1）watch里面监听

​		■第一种写法：监听简单数据类型

```vue
watch:{
	obj(newval,oldval){
		console.log(newval,oldval)
	},
}
```

​		■第二种写法可设置deep为true对数据进行深层遍历监听，如果监听的是复杂数组类型例如数组、对象等

```vue
watch:{
	obj:{
		handler(newval,oldval){
			console.log(222)
			console.log(newval,oldval)
		}，
		deep: true
	}
}
```

​	2）computed里面监听

computed里面的依赖改变时，所计算的属性或作出事实的改变

### 8、watch中的deep：true是如何实现的

​        当用户指定了`watch`中的deep属性为`true`时，如果当前监控的值是数组或者对象类型，会对数组或对象中的每一项进行求值，此时会将当前`watcher`存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新

### 9、为何vue采用异步渲染

​        因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，如果数据更新次数多性能会很差。所以为了**性能考虑**，Vue会在本轮数据更新完成后，再去异步更新视图，即只根据最后更新完的新数据进行渲染

### 10、nextTick实现原理

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202213443227.png" alt="image-20201202213443227" style="zoom:50%;" />

### 11、vue中computed的特点

​        计算属性在引用的时候，不要加()去调用，当成普通的变量用就好；        

​        计算属性的求值结果，会被缓存起来，方便下次继续使用；如果计算属性方法中，所依赖的任何数据，都没有发生过变化，则不会重新对计算属性求值。

​        只要计算属性这个function内部所用到的data中的数据发生了变化，就会立即重新计算这个计算属性的值

### 12、vue组件的生命周期

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202222003888.png" alt="image-20201202222003888" style="zoom:50%;" />

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202222103448.png" alt="image-20201202222103448" style="zoom:50%;" />

vue的生命周期函数可以八部分：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed

#### 	beforeCreate

​	在beforeCreate生命周期函数执行的时候, data和methods等等中的数据都还没有没初始化，所以此时调用这些数据，只会显示undefined

#### 	created

​	在created中, data和methods都已经被初始化好了！如果要调用methods中的方法，或者操作data中的数据，最早,只能在created中操作

#### 	beforeMount

​	此时模板已经在内存中编辑完成了,但是尚末把模板渲染到页面中，在beforeMount 执行的时候，页面中的元素，还没有被真正替换过来,只是之前写的一些模板字符串

#### 	mounted

​	此时内存中的模板,已经真实的挂载到了页面中,用户已经可以看到渲染好的页面了，mounted是实例创建期间的最后一个生命周期函数,当执行完mounted 就表示,实例已经被完全创建好了，此时如果没有其它操作的话，这个实例就一直存在我们的内存中

beforeUpdate和updated只有在数据被修改的时候才会触发

#### 	beforeUpdate

​	当执行beforeUpdate 的时候，页面中的显示的数据还是旧的，此时data 数据是最新的，页面尚未和最新的数据保持同步

#### 	updated

​	updated执行后，页面和data 数据已经保持同步了，都是最新的

beforeDestroy和destroyed被执行时表示vue实例已经进入销毁阶段，可以在控制台上执行vm.$destroy()

#### 	beforeDestroy

​	销毁之前执行，当beforeDestroy函数执行时，表示vue实例已从运行阶段进入销毁阶段，vue实例身上所有的方法与数据都处于可用状态

#### 	destroyed

​	当destroyed函数执行时，组件中所有的方法与数据已经被完全销毁，不可用

### 13、Vue路由守卫有哪些，怎么设置，使用场景等

```javascript
常用的两个路由守卫：router.beforeEach 和 router.afterEach

每个守卫方法接收三个参数：
	to: Route: 即将要进入的目标 路由对象
	from: Route: 当前导航正要离开的路由
	next: Function: 一定要调用该方法来 resolve 这个钩子。

在项目中，一般在beforeEach这个钩子函数中进行路由跳转的一些信息判断。判断是否登录，是否拿到对应的路由权限等等。
```

### 14、vue的双向绑定原理

采用数据劫持，结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

以下是详解：

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202202523885.png" alt="image-20201202202523885" style="zoom:50%;" />

在vue初始化的时候，会调用一个方法`initData`，通过`vm.$options.data`能够获取到用户传入的数据，然后对数据进行观测；

调用`Observer`方法，将数据传给它，然后判断数据是否被观察过了，如果没有被观测过，就`new`一个`Observer`，对该数据进行观测；

观测时分两种情况：

1、观测的数据是对象(非数组)，则调用`walk`方法；在该方法中，遍历对象属性，使用`defineReactive`定义响应式变化，在`defineReactive`中使用`Object.defineProperty`重新定义数据，当用户获取数据时会调用`get`方法，调用时会进行依赖收集，即收集当前的`watcher`；当数据改变时，触发`set`，此时先判断当前的`value`和新的`value`是否一致，不一致的话调用`notify`方法，触发数据对应的依赖进行更新。

2、如果观测的对象时数组，则先判断当前是否支持原型链，如果支持，将数组的`_proto_`指向我们改写的数组原型方法`arrayMethods`，这个方法主要是拦截数组的七个会改变自身数值的方法，(`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`)，当用户调用数组的这些方法时，首先还是会执行原生的方法，还会通知视图更新。如果有新增的数据，还需要对新增的内容进行观测(`observeArray`)，同时还需要对每个数组元素进行观测

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202211953545.png" alt="image-20201202211953545" style="zoom:50%;" />

### 15、如果对vuex里的state状态改变是非常敏感的,可以怎么做来监听状态的改变

在引用vuex的state的组件中，使用computed计算属性定义一个变量，return Vuex中的state，然后使用watch对变量进行监听，如果state发生变化，watch就可以监听到。

### 16、mutations和actions的区别

mutations 必须是同步操作，action则可以是异步操作

action通过调用mutations的方法改变store中的值

```javascript
调用mutations的方法： this.$store.commit('function', 'param')
调用action的方法： this.$store.dispatch('function')
```

### 17、vue中mixin是什么，mixin冲突怎么解决

mixin文件是一个对象，可以包含vue组件的任意成分。是分发Vue组件可复用功能的非常灵活的方式，当mixin被组件使用时，所有minxin里的属性/方法会与组件里的属性/方法混合。

在Vue组件中可以有mixins属性，该属性值类型为数组。将mixin引入，作为mixins数组的元素mixins: [mixin]

当mixin中的数据、方法或任何组件选项与组件中的选项具有相同的名称时，可能会发生组件与其mixin之间的命名冲突。如果发生这种情况，则组件本身的属性将优先。

### 18、vue中使用v-for的key值问题

#### 为什么需要key

**主要是用来提供给DOM的diff算法，因为diff算法会比较节点上的key，如果新的节点在旧的节点中已经存在，即节点的标签和key都相同，但位置发生改变，则将元素复用并进行移动，而不会重新创建或者删除节点；**

举个栗子：有ABCD四个旧节点，经过一些操作后变成DABC，此时先将新节点中的第一个节点D取出来和旧节点进行对比，发现在旧节点中有一个节点的key和D相同，那就复用旧节点的D，并将旧节点的D移动到最前面，而不需要去创建新节点；

**如果没有key值，那么diff算法在比较节点时，就暴力地按照位置进行比对；**

举个栗子：有ABCD四个旧节点，经过一些操作后变成DABC，此时因为没有key值，所以直接拿第一个新节点D与旧节点A对比，如果新节点D与旧节点A的标签一样，但内容不一样，则会操作DOM，将旧节点A修改为新节点D；然后拿第二个新节点A与旧节点B进行比较，如果新节点A与旧节点B标签不一样，则删除旧节点B，新建节点A，以此类推。

**所以key值可以提供性能，减少操作DOM节点**

#### 为什么最好使用列表项的id作为key值而不是用index

使用列表项的id作为key值，当列表项发生删除或者增加时，各个列表项的key不会被重新渲染，如果使用index作为列表项的key，当列表项发生删除或者增加时，增加或者删除的列表项后面key都要被重新渲染一遍，所以使用列表项的id作为key值相比于使用index作为列表项的key值，性能有所提升。

举个栗子：有ABCD四个旧节点，删除节点B之后变成ACD，此时如果以index作为key值，那么新节点CD节点的key要从原来的2、3变为1、2，同时，diff算法比较时，会将旧节点的B/C与新节点C/D进行比较，发现旧节点的B(C)与新节点的C(D)不一样，就会操作DOM，将旧节点B(C)改为新节点的C(D)。最后旧节点的末尾还有一个D，直接删除；如果是以列表项id作为key值，那么新节点ACD都可以在旧节点中找到与之具有相同key值的节点，比较第二个和第三个新节点时，旧节点CD会被依次移动到A后面，此时B被挤到最后面，比较完成后直接被删除。

### 19、何时需要使用beforeDestory

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202222739183.png" alt="image-20201202222739183" style="zoom:50%;" />

### 20、为什么v-for与v-if不能连用

因为v-for的优先级高于v-if。如果同时有v-for和v-if，那么先执行v-for，将列表项全部渲染出来，再给每一个列表项添加v-if = false，这么做性能低下，做了许多无用功。

### 21、虚拟DOM

 		虚拟DOM其实是一个js对象，是使用js对象来模拟DOM，如果在一次操作中有多次对DOM节点的更新，每次都立即更新视图会很影响性能，所以虚拟DOM不会立即去操作DOM，而是将多次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性更新到DOM树上，再进行后续操作，避免大量无谓的计算量。

### 22、keep-alive的作用

 keep-alive用来缓存组件，避免多次加载相应的组件，减少性能消耗。

举个栗子：从页面1跳转到页面2后，从页面2回退到页面1时不用在重新执行页面1的代码，只会从缓存中加载之前已经缓存的页面1，不会触发页面1中的created钩子函数，这样可以减少加载时间及性能消耗，提高用户体验性。

**什么时候使用keep-alive**

如果需要频繁切换路由，这个时候就可以考虑用keep-alive了，来达到避免数据的重复请求的目的。

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201211105906824.png" alt="image-20201211105906824" style="zoom:50%;" />

## 二、HTML和CSS的面试题

### 1、行内元素有哪些?  块级元素有哪些?   CSS的盒模型?

行内元素：a、em、i、big、strong、input、label、span等等

块级元素：div、form、h标签、hr、ul、ol、table等等

css的盒模型(四部分)：内容(content)、内边距（padding）、边框（border）、外边距（margin）

设置盒子模型：box-sizing：content-box | border-box，默认值：content-box

content-box：

padding和border不被包含在定义的width和height之内，即设置的宽高只是content的宽高。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding )

此属性表现为标准模式下的盒模型。

border-box：

padding和border被包含在定义的width和height之内，即设置的宽高包括了content、padding、border。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )

### 2、CSS引入的方式有哪些? link和@import的区别是?

css引入方式：行内样式(内联方式)、内部样式(嵌入方式)、外部样式(链接方式)

link和@import的区别：

①link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载；

②link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器(IE5及以下)不支持；

③@import可以在CSS中再次引入其他样式表

④link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。

### 3、CSS选择符有哪些?  哪些属性可以继承?  优先级算法如何计算?  内联和important哪个优先级高?

CSS选择符(器)有：id选择器(`#id`)、元素选择器(`dom`)、类选择器(`.class`)、子元素选择器(`div1 > div2`)、后代选择器(`div1 div2`)、相邻选择器(`div1 + div2`)、通配符选择器(`*`)、伪类选择器(`a:hover`)、属性选择器(`div[class="xxx"]`)

可以继承的属性：font、font-size、font-weight、text-align、line-height、color等等

 优先级算法计算：

​	1.优先级就近原则，同权重情况下样式定义最近者为准;
​	2.载入样式以最后载入的定位为准;
​	3.!important > id > class > tag;
​	4.!important比内联优先级高，但内联比id要高;

内联和important相比，important优先级高

### 4、前端页面有哪三三层构成，分别是什么?作用是什么?

三层构成：结构层(HTML)、样式层(CSS)、行为层(JavaScript)。

作用：

​	结构层(HTML)：用于存储客户想要阅读或查看的所有内容，包括文字，图片，视频等等

​	样式层(CSS)：决定了结构层中的数据以何种形式展现，提高用户视觉体验。

​	行为层(JavaScript)：使得页面具有交互性，允许页面响应用户操作或基于一组条件进行更改

### 5、如何居中一个元素?

#### 居中浮动元素的两种方法：

第一种方法是在需要居中的元素外面加一层div，然后给该div一个width，并设置其margin为auto，浮动元素的width设置为100%。

第二种方法是给元素一个宽度width，同时设置元素的margin-left的值为50%，使用相对定位(position: relative)，left的值为该元素宽度的负一半(left: -50%width)

#### 居中普通div元素的3种方法

第一种是使用flex布局，通过 `align-items: center`和`justify-content: center`设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。

第二种方法是div元素的宽高固定，利用绝对定位，先将元素的左上角通过`top: 50%`和 `left: 50%`定位到页面的中心，然后再通过`margin: -50%height -50%width`负值来调整元素的中心点到页面的中心。

第三种是利用绝对定位，先将元素的左上角通过`top: 50%`和`left: 50%`定位到页面的中心，然后再 通过`transform: translate(-50%, -50%)`来调整元素的中心点到页面的中心。

### 6、HTML5和css3新特性

#### HTML5：

文档声明简化了

```html
html5：
	<！DOCTYPE html>
html5之前：
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
```

新增/废除一些标签：

​	新增：语义化标签：header、footer、nav、article、aside、section、canvas、progress、meter

​				属性：input新增email、date、datetime、tel、

​	废除：frame、frameset、big、font

​				属性：link标签和a标签中的charset、link中的target、div、h标签、intput标签和p标签的align

#### CSS3：

过渡效果transition

形状转换transform

盒子阴影box-shadow

图像边框border-image

文字换行

​	word-break：normal|break-all|keep-all; 

​	word-wrap: normal|break-word; 

​	超出省略号  text-overflow:clip|ellipsis|string 

颜色rbga：a是不透明度

布局：弹性布局flex、栅格布局grid

盒模型定义：

​	 box-sizing:border-box的时候，边框和padding包含在元素的宽高之内！              

​	box-sizing:content-box的时候，边框和padding不包含在元素的宽高之内！

### 7、css样式为何放前面，js文件为何放后面

​		如果将css放在头部，css的下载解析是可以和html的解析同步进行的，放到尾部，要花费额外时间来解析CSS，并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。

​		因为当浏览器解析到script的时候，就会立即下载执行，中断html的解析过程，如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。

### 8、display:none，visibility:hidden，opactiy:0的区别

display:none隐藏后不占据额外空间，它会产生回流和重绘，而visibility:hidden和opacity:0元素虽然隐藏了，但它们仍然占据着空间，它们俩只会引起页面重绘。

display:none不会被子元素继承；visibility:hidden 会被子元素继承，可以通过设置子元素visibility:visible 使子元素显示出来；opacity: 0 也会被子元素继承，但是不能通过设置子元素opacity: 1使其重新显示

对于过渡效果，只对opacity有效，对其他两个无效。

### 9、 padding , margin 百分比单位依据

容器的宽度：width

### 10、什么是BFC

BFC (Block formatting context)：块级格式化格式化上下文，它是一个独立的渲染区域，只有Block-level box(块级盒)参与， 它规定了内部的Block-level Box(块级盒)如何布局，并且与这个区域外部毫不相干。

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

#### 创建BFC

- 1、float的值不是none。

- 2、position的值不是static或者relative。

- 3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex

- 4、overflow的值不是visible

### 11、绝对定位元素 与 非绝对定位元素的百分比计算的区别

绝对定位元素的宽高百分比是相对于临近的 position 不为 static 的祖先元素的 paddingbox 来 计算的。 

```css
.box1 {
	width: 100px;
    height: 100px;
    background-color: blueviolet;
    padding: 25px;
    position: relative;
}
.box2 {
	position: absolute;
    width: 50%;
    height: 50%;
    background-color: cyan;
}
<div class="box1">
	<div class="box2"></div>
</div>
```

<img src="D:\typora笔记\面试.assets\image-20201113114051651.png" alt="image-20201113114051651" style="zoom:67%;" />

```css
.box3 {
    width: 100px;
    height: 100px;
    background-color: blueviolet;
    position: relative;
}
.box4 {
    position: static;
    width: 80px;
    height: 80px;
    background-color: blue;
}
.box5 {
    position: absolute;
    height: 50%;
    width: 50%;
    background-color: cyan;
}
<div class="box3">
    <div class="box4">
        <div class="box5"></div>
    </div>
</div>
```

![image-20201113114427717](D:\typora笔记\面试.assets\image-20201113114427717.png)

非绝对定位元素的宽高百分比则是相对于父元素的 contentbox 来计算的。

```css
.box6 {
    height: 120px;
    width: 120px;
    background-color: darkblue;
}
.box7 {
    width: 50%;
    height: 50%;
    background-color: darkorchid;
}
<div class="box6">
    <div class="box7"></div>
</div>
```

<img src="D:\typora笔记\面试.assets\image-20201113114640323.png" alt="image-20201113114640323" style="zoom:67%;" />

### 12、margin重合问题

① 相邻兄弟元素的`marin-bottom`和`margin-top`的值发生重叠。这种情况下我们可以通过设置其中一个元素为`BFC`来解决。

② 父元素的`margin-top`和子元素的`margin-top`发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这 一点来解决这个问题。

③ 高度为`auto`的父元素的`margin-bottom`和子元素的`margin-bottom`发生重叠。它们 发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置`border-bottom、 padding-bottom`来分隔它们，也可以为父元素设置一个高度，`max-height`和`min-height`也能解决这个问题。

④ 没有内容的元素，自身的`margin-top`和`margin-bottom`发生的重叠。我们可以通过为其设置 `border`、`padding`或者高度来解决这个问题

### 13、overflow:scroll; 时不能平滑滚动的问题怎么处理？

以下代码可解决这种卡顿的问题：`-webkit-overflow-scrolling: touch;`

是因为这行代码启用了硬 件加速特性，所以滑动很流畅。

### 14、如何解决border重叠问题

边框重叠可以分为两种情况，分别为：

1、div，ul等元素盒子设置边框后的重叠问题

```css
border: 1px solid #000000;
margin:0px -1px -1px 0px ;
```

2、table表格设置边框后的重叠问题

```css
table {
	border-collapse: collapse;
}
table td {         
    border: 1px solid #000000;
    padding: 20px 30px;
}
```

### 15、float的工作原理

浮动元素是脱离文档流的，不占据空间。

浮动的元素会尽量向左 / 右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘为止

### 16、如何去除img元素底部的空白

css中对于`display: inline`元素的`vertical-align`的默认值是`baseline`，用一张图来观察`vertical-align`各个值之间的差别，可以看出`baseline`和`bottom`之间有一定的距离

<img src="D:\typora笔记\面试.assets\image-20201119133622961.png" alt="image-20201119133622961" style="zoom:67%;" />

`img`标签默认就是一个行内元素，所以图片下面那一道空白正是`baseline`和`bottom`之间的这段距离。即使只有图片没有文字，只要是`inline`的图片这段空白都会存在。要去掉这段空白，最直接的办法是将图片的`vertical-align`设置为其他值。如果在同一行里有文字混排的话，那应该是用`bottom`或是`middle`比较好。

另外，`top`和`bottom`之间的值即为`line-height`。假如把`line-height`设置为0，那么`baseline`与`bottom`之间的距离也变为0，那道空白也就不见了；在没有设置`line-height`的情况下把`font-size`设为0也可以达到同样的效果。当然，这样做的后果就是不能图文混排了。

### 17、两栏布局、三栏布局

**两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局**

(1) 利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。

(2) 利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。

(3) 利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。

(4) 利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。

**三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局**

(1) 利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的 margin 的 值。

(2) 利用 flex 布局的方式，左右两栏的放大和缩小比例都设置为 0，基础大小设置为固定 的大小，中间一栏设置为 auto。

(3) 利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的 margin 值，注意这种方式，中间一栏必须放到最后。

(4) **圣杯布局**，利用浮动和负边距来实现。**父级元素**设置左右的 padding，三列均设置向左 浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行， 通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。

(5) **双飞翼布局**，也是利用浮动和负边距来实现，左右位置的保留是通过**中间列**的 margin 值来实现的，而不是通过父元素的 padding 来实现的。

### 18、CSS如何保证类名不重复

`VUE`中提供了`scoped`，在style标签中加入`scoped`属性，相当于在元素中添加了一个唯一的属性来进行区分

`CSS Modules`通过**给样式名加hash字符串后缀**的方式，实现特定作用域语境中的样式编译后的样式在全局唯一。

### 19、canvas常用方法

```js
//绘制矩形，前两个参数代表矩形的起点，后两个参数代表矩形的宽高
canText2.rect(50,25,100,100);
//绘制圆形，arc(x,y,r,SAngle,eAngle,counterclockwise)方法创建弧/曲线
// x, y分别为圆的中心的横纵坐标
// r为圆的半径
// sAngle起始角，以弧度计。即多少π (弧的圆形的三点钟位置是0度)
// eAngle结束角，以弧度计。即多少π
// counterclockwise 选填项。规定顺时针还是逆时针绘图。false为顺时针, true为逆时针，默认是false
canText3.arc(75,75,70,0,1*Math.PI,false);
//需要填充的颜色
canText2.fillStyle="greenyellow";
//执行填充颜色的操作
canText2.fill();
//将绘制的图形展示出来
canText.stroke();
//先开始一段路径，声明图形绘制从这段程序开始
canText.beginPath();
//定义一个起点，即我们要绘制的图形的起点
canText.moveTo(50,50);
//添加1个或多个点并将初始点与该点连接起来
canText.lineTo(150,50);
 //关闭路径，表示绘制图形结束
canText.closePath();
```

### 20、css中两种动画：transition和animation

```js
语法：transition: property duration timing-function delay;

transition-property:指定CSS属性的name, 
transition-duration:需要指定多少秒或毫秒才能完成
transition-timing-function:指定transition效果的转速曲线
transition-delay:定义trinsition效果开始的时候，即延时多少时间开始过渡效果

语法: animation:  name duration timing-function delay iteration-count direction fill-mode   play-state;

animation-name：指定动画特效的名称
animation-duration：动画特效需要多少秒或毫秒完成
animation-timing-function：设置动画特效将如何完成一个周期，效果路线
animation-delay：设置动画特效在启动前的延迟间隔。
animation-iteration-count：定义动画特效的播放次数。
animation-direction：指定是否应该轮流反向播放动画特效。
animation-fill-mode：规定当动画特效不播放时(当动画完成时，或当动画有一个延迟未开始播放时)，要应用到元素的样式。
animation-play-state：指定动画特效是否正在运行或已暂停。
```

### 21、font-face是什么

font-face是css3中允许使用自定义字体的一个模块。

用法：`@font-face{font-family: myFirstFont; src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9 */}`

### 22、rem和em的区别

rem是基于html元素的字体大小来决定，而em则根据使用它的元素的大小决定。

二者都是灵活、可扩展的单位，由浏览器转换为像素值，具体取决于您的设计中的字体大小设置。

## 三、网络面试题

### 1、HTTP协议及HTTP缓存

​		超文本传输协议（HTTP，HyperText Transfer Protocol)是一种实现客户端和服务器之间通信的响应协议，它是用作客户端和服务器之间的请求。

**HTTP特性**

HTTP 是无连接无状态的
HTTP 一般构建于 TCP/IP 协议之上，默认端口号是 80
HTTP 可以分为两个部分，即请求和响应。

**HTTP** 常用的协议包括哪些请求？

GET、POST、PUT、DELETE

URL 全称为资源描述符，可以这么认为：一个 URL 地址对应着一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE就对应着对这个资源的查询，修改，增添，删除4个操作。

HTTP 请求由 3 个部分构成，分别是：状态行，请求头(Request Header)，请求正文。

HTTP 响应由 3 个部分构成，分别是：状态行，响应头(Response Header)，响应正文

#### **HTTP缓存机制(浏览器缓存机制)**

http缓存分为**强缓存**与**协商缓存**

强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。

​		用户发起了一个`http`请求后，浏览器发现先本地已有所请求资源的缓存，便开始检查缓存是否过期。有两个`http`头部字段控制缓存的有效期：`Expires`和`cache-Control`，浏览器是根据以下两步来判定缓存是否过期的：
1) 查看缓存是否有`cache-Control`的`s-maxage`或`max-age`指令，若有，则使用响应报文生成时间`Date + s-maxage/max-age`获得过期时间，再与当前时间进行对比 (s-maxage适用于多用户使用的公共缓存服务器);
2) 如果没有`cache-Control`的`s-maxage`或`max-age`指令，则比较`Expires`中的过期时间与当前时间。`Expires`是一个绝对时间。

协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。

​		当第一次请求时服务器返回的响应头中没有`Cache-Control`和`Expires`或者`Cache-Control`和`Expires`过期还或者它的属性设置为`no-cache`时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。

​	浏览器第一次发出请求一个资源的时候，服务器会返回一个`Last-Modify`到hearer中， `Last-Modify`含义是最后的修改时间。当浏览器再次请求的时候，`request`的请求头会加上`if-Modify-Since`，该值为缓存之前返回的`Last-Modify`。服务器收到`if-Modify-Since`后，根据资源的最后修改时间`(last-Modify)`和该值`(if-Modify-Since)`进行比较，如果相等的话，则命中缓存，返回304，否则, 如果`Last-Modify > if-Modify-Since`, 则会给出200响应，并且更新`Last-Modify`为新的值。

### 2、HTTP 中， POST与 GET 的区别

1）Get是在请求过程中会把数据暴露在url上，不安全，而post不会

2)  Get请求传送的数据量小，受到地址栏长度影响，最多只能2k；而Post可以传送的数据量大，一般默认为不受限制。

3)  Get可以保存为书签，而post不行

4)  Get的参数只能是ASCII，而Post没有要求

**get和post的content-type是什么意思？**

`content-type`是用来指定消息体的格式的，一般来说get不需要设置，而post需要设置。

### 3、HTTP与HTTPS

① https协议需要到ca申请证书或自制证书。

② http的信息是明文传输，https则是具有安全性的ssl加密。

③ http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。

④ http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

**HTTPS建立连接的过程**

```js
(1) 浏览器发送一个连接请求给服务器;服务器将自己的证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息返回客户端;
(2) 客户端浏览器检查服务器传送到CA证书是否由自己信赖的CA中心签发。若是，执行4步;否则，给客户一个警告信息：询问是否继续访问。
(3) 客户端浏览器比较证书里的信息，如证书有效期、服务器域名和公钥S_PK，与服务器传回的信息是否一致，如果一致，则浏览器完成对服务器的身份认证。
(4) 服务器要求客户端发送客户端证书(包含客户端公钥C_PuKey)、支持的对称加密方案及其他相关信息。收到后，服务器进行相同的身份认证，若没有通过验证，则拒绝连接;
(5) 服务器根据客户端浏览器发送到密码种类，选择一种加密程度最高的方案，用客户端公钥C_PuKey加密后通知到浏览器;
(6) 客户端通过私钥C_PrKey解密后，得知服务器选择的加密方案，并选择一个通话密钥key（即对称加密的key），接着用服务器公钥S_PuKey加密后发送给服务器;
(7) 服务器接收到的浏览器传送到消息，用私钥S_PrKey解密，获得通话密钥key。
(8) 接下来的数据传输都使用该对称密钥key进行加密。
```

### 4、了解基本的浏览器渲染

​	①解析HTML生成DOM树
​	②解析CSS生成CSSOM规则树
​	③将DOM树与CSSOM规则树合并在一起生成渲染树Render Tree。
​	④遍历渲染树开始布局，计算每个节点的位置大小信息
​	⑤将渲染树每个节点绘制到屏幕

#### 	4.1 css加载会不会阻塞页面渲染,为什么？

​		css加载会阻断页面的渲染；

​		原因：浏览器渲染页面时，DOM解析和CSS解析是两个并行的进程，此时CSS加载不会阻塞DOM的解析，但是渲染树的渲染是依赖于DOM树和CSS树的，必须等待到CSS树构建完成才能渲染，CSS没有加载完成，CSS树没有构建完成，渲染就不会开始，所以CSS加载是会阻塞Dom的渲染的；由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

### 5、三次握手四次挥手

**为什么要三次握手？**

​		说法1：在只有两次“握手”的情形下，假设客户端想跟服务器建立连接，但是却因为中途连接请求的数据报丢失了，故客户端不得不重新发送一遍；这个时候服务器端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候客户端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下服务器端将先后收到2次请求，并持续等待两个客户端请求向他发送数据...问题就在这里，客户端实际上只有一次请求，而服务器端却有2个响应，极端的情况可能由于客户端端多次重新发送请求数据而导致服务器端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

​		说法2：client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，知道某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。

**为什么要四次挥手？**

​		假如现在你是客户端你想断开跟服务器的所有连接，第一步，你自己先停止向服务器端发送数据，并等待服务器的回复。但事情还没有完，虽然你自身不往服务器发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故服务器端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

​		TCP建立连接要进行3次握手，而断开连接要进行4次：这是由于TCP的半关闭造成的，因为TCP连接是全双工的(即数据可在两个方向上同时传递)，所以进行关闭时每个方向上都要单独进行关闭，这个单方向的关闭就叫半关闭。关闭的方法是一方完成它的数据传输后，就发送一个FIN来向另一方通告将要终止这个方向的连接。当一端收到一个FIN,它必须通知应用层TCP连接已终止了这个方向的数据传送，发送FIN通常是应用层进行关闭的结果。

### 6、常见状态码及原因短语

```javascript
200 OK 客户端请求成功。
301 Moved Permanently 请求永久重定向。
302 Moved Temporarily 请求临时重定向。
304 Not Modified 文件未修改，可以直接使用缓存的文件。
400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized 请求未经授权，无法访问。
403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
404 Not Found 请求的资源不存在，比如输入了错误的URL。
500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。
```

### 7、层次划分

<img src="D:\typora笔记\面试.assets\image-20200706203651364.png" alt="image-20200706203651364" style="zoom:50%;" />

数据链路层的协议：SDLC、HDLC、PPP、STP

网络层：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF

传输层：TCP、UDP

应用层：FTP、SMTP、HTTP

### 8、TCP协议和UDP协议

TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要通过四次挥手拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象。

**TCP** **与** **UDP** **的区别：**

TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。

UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

### 9、TCP滑动窗口

TCP滑动窗口具有拥塞控制和保证可靠性的功能

对于拥塞控制，滑动窗口是可变大小的，如果滑动窗口发生拥塞控制则将窗口大小置为1，然后对长度进行2的指数增长，直到窗口大小可满足数据传输或者大小到达阈值。

对于可靠性，接收双方具有同样大小的窗口，然后对数据进行编号，如果接收端没有收到某部分信息就会发送请求给发送方然后重新发送未接收到的部分。

### 10、HTTP报文内容

<img src="D:\typora笔记\面试.assets\image-20201013001157290.png" alt="image-20201013001157290" style="zoom:50%;" />

https://www.cnblogs.com/myseries/p/11239662.html

## 四、优化问题

### 1、前端优化

1、babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_modules中的js文件，其次在缓存当前转译的js文件，设置loader: 'babel-loader?cacheDirectory=true'

2、框架或者文件采用按需加载，例如做项目过程中使用了elementUI或者cube-ui，不需要全部引入到项目中，按需加载即可

3、项目中用到的图片尽量使用svg或字体图标。

4、采用本地存储

5、使用事件代理、减少页面的回流和重绘

### 2、webpack是用来干嘛的

是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。

**作用**

（1）重新加载编译，将浏览器不认识的语法编译成浏览器认识的语法。less编译成css,ES6语法转换成ES5。

（2）减少io请求。发送请求，会发送一个html文件到浏览器，这是，打开控制台会发现html页面通过script，link等标签引用的静态，浏览器会再次发出请求去获取这些资源。使用webpack打包，将所有的静态资源都合并好了，减少了io请求。

## 五、JS面试题

### 1、浏览器提供给js哪些API

控制台打印：console.log()

弹窗提醒：alert()

获取dom元素：document.getElementById()、document.getElementByClassName()、document.getElementByTagName()、document.querySelector()、document.querySelectorAll()

添加dom元素：document.createElement()、document.createTextNode()、el.appendChild()

储存：window.localstorage.setItem()、window.localstorage.getItem()、window.sessionStorage.setItem()、window.sessionStorage.getItem()

### 2、script标签一般放在那里,为什么,defer和async的区别

script标签一般放在body后面

如果将script放在<head>里，浏览器解析HTML，发现script标签时，会先下载完所有这些script，再往下解析其他的HTML，浏览器最多只能同时下载两个JS，且浏览器下载JS时，不能同时并行解析HTML，会让网页内容呈现滞后，导致用户感觉到卡。

但是将script放在尾部的缺点，是浏览器只能先解析完整个HTML页面，再下载JS。而对于一些高度依赖于JS的网页，就会显得慢了。所以将script放在尾部也不是最优解。

script如果没有defer或async，浏览器遇到js文件会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。如果带有defer或async，那么加载js文件，相对于解析html是异步的，加载js文件不阻断html文件的解析。

带有async属性的script，只要下载完就执行，所以这可能导致后面的js文件比前面的js文件先执行；同时，它的执行会阻断html的解析

带有defer属性的script，在HTML解析完成之后再执行，同时，能保证js文件按照引入的顺序，有序执行。

### 3、闭包

闭包是指有权访问另外一个函数作用域中的变量的函数，是函数内部与外部连接的桥梁

正常函数执行完毕后，里面声明的变量被垃圾回收处理掉，但是闭包可以让作用域里的变量，在函数执行完之后依旧保持，没有被垃圾回收处理掉。

缺点： ①闭包会导致内存占用过高，因为变量都没有释放内存；②内存泄漏

解决办法：退出函数之前，将不使用的局部变量全部删除或者赋为null

优点：①可以读取函数内部的变量；②让这些变量的值始终保持在内存中，不会在函数被调用后被自动清除。

**实现一个闭包**——封装变量

```js
var fn = function() {
    var name = '孙某人'
    return {
        getName: function() {
            return name
        },
        setName: function(newName) {
            return name = newName
        }
    }
}
var fn1 = new fn()
console.log(fn1.name); // undefined
console.log(fn1.getName()); // 孙某人
```

### 4、原型链

原型链就是js引擎在访问一个对象属性的时候，如果对象自身没有找到该属性的情况下会去它的原型对象中查找，如果还没有，会去它的原型对象的原型对象中查找，递归访问`_proto_`，如此循环直到顶层的Object对象的原型对象为止的这么个机制

**原型链：** 是由子对象对父对象进行多次原型继承形成的链式关系。当调用子对象的某个属性或方法时，javascript会向上遍历原型链，直到找到为止，没有则返回undefined。

![image-20201026125231016](D:\typora笔记\面试.assets\image-20201026125231016.png)

**原型链继承的三种方法**

https://zhuanlan.zhihu.com/p/160868667

原型链的终点：**Object.prototype**

### 5、数组去重

通过ES6的新特性Set，它类似于数组，但其中的元素都是唯一的，没有重复的，所以可以利用Set实现数组去重。

var arr = [1, 2, 3, 1, 2]; var newArr= [...new Set(arr)]

### 6、如何判断变量是数组还是object

用typeof判断数组或者object，返回的均为object；

用instanceof、constructor、Object.prototype.toString.call()判断都可以，用法如下：

```javascript
var arr = new Array();
var arr = ['aa','bb','cc'];
var obj = {
	'a': 'aa',
	'b': 'bb',
	'c': 'cc'
};
console.log(arr instanceof Array); //true
console.log(arr instanceof Object); //true
console.log(obj instanceof Array); //false
console.log(obj instanceof Object); //true

console.log(arr.constructor === Array); //true
console.log(arr.constructor === Object); //false
console.log(obj.constructor === Object); //true

var a = NaN;
var b= '222';
var c = null; 
var d = false;
var e = undefined;
var f = Symbol();
var arr = ['aa','bb','cc'];
var obj = {
'a': 'aa',
'b': 'bb',
'c': 'cc'
};
var res = Object.prototype.toString.call(arr);
console.log(res); //[object Array]
var res2 = Object.prototype.toString.call(obj);
console.log(res2); //[object Object]
var res3 = Object.prototype.toString.call(a);
console.log(res3); //[object Number]
var res4 = Object.prototype.toString.call(b);
console.log(res4); //[object String]
var res4 = Object.prototype.toString.call(c);
console.log(res4); //[object Null]
var res5 = Object.prototype.toString.call(d);
console.log(res5); //[object Boolean]
var res6 = Object.prototype.toString.call(e);
console.log(res6); //[object Undefined]
var res7 = Object.prototype.toString.call(f);
console.log(res7); //[object Symbol]
```

### 7、js给input提供了哪些监听事件

1.onfocus  当input 获取到焦点时触发

2.onblur  当input失去焦点时触发，注意：这个事件触发的前提是已经获取了焦点再失去焦点的时候会触发相应的js

3.onchange 当input失去焦点并且它的value值发生变化时触发

4.onkeydown 在 input中有键按住的时候执行一些代码

5.onkeyup 在input中有键抬起的时候触发的事件，在此事件触发之前一定触发了onkeydown事件

6.onclick  主要是用于 input type=button，当被点击时触发此事件

7.onselect  当input里的内容文本被选中后执行一段，只要选择了就会触发，不是非得全部选中

8.oninput  当input的value值发生变化时就会触发，不用等到失去焦点（与onchange的区别）

### 8、javascript数据基本类型有哪些？

null、boolean、string、undefined、number、symbol(ES6新加)

### 9、事件代理

​		事件委托也叫事件代理，是利用事件冒泡机制，减少DOM操作。当HTML中一个子元素的click、mouseup、mousdown、keyup、keydown等等事件被触发，那么其父元素上的相应事件也会被触发。当这样的子元素一多，在事件被触发之后执行的DOM操作就会很多，如果将这些操作委托给父元素，那么将可以减少很多的DOM操作。

#### 9.1 阻止事件冒泡

在除IE以外其他的浏览器中通过`e.stopPropagation()`方式阻止事件的冒泡；

在IE浏览器中通过`e.cancleBubble=true`阻止事件冒泡。

**实现一个事件代理**

```html
<ul id="box">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
    <li>7</li>
    <li>8</li>
</ul>
```

```js
var oBox = document.getElementById('box')
oBox.onclick = function(e) {
    console.log(e.target.innerHTML)
}
```

### 10、import、export以及export default的区别

export用于对外输出本模块(一个文件可以理解为一个模块)变量的接口
import用于在一个模块中加载另一个含有export接口的模块。

1、export与export default均可用于导出常量、函数、文件、模块等
2、你可以在其它文件或模块中通过import+(常量|函数|文件|模块)名的方式，将其导入，以便能够对其进行使用
3、在个文件或模块中，export、import可以有多 个，export default仅有一个
4、通过export方式导出， 在导入时要加{ }, export default则不需要，即export与export default可以实现同样的目的，只是用法有些区别。

### 11、手写原生ajax

```js
function ajax (method = 'get', url, data = '', success) {
    // 第一步：创建XMLHttpRequest对象，用于在后台与服务器交换数据
    var xhr;
    if (window.XMLHttpRequest) {
        //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
        xhr = new XMLHttpRequest();
    } else {
        // IE6, IE5 浏览器执行代码
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
    }

    if(method.toLowerCase === 'post') {
        // 如果请求方式是post的话，还需要加一个请求头
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        
        // 第二步：使用open方法设置与服务器的交互信息；
        // open 三个参数：open(method, URL, Asynchronous) => 第一个表示请求的方式，第二个表示请求的地址，第三个表示是否支持异步执行
        xhr.open(method, url ,false);

        // 第三步：发送请求
        xhr.send(data);
    } else {
        xhr.open(method, url ,false);
        xhr.send(null);
    }
    
    // 第四步：注册事件，当onreadystatechange状态改变就会调用
    xhr.onreadystatechange = function() {
        // readyState === 4说明请求已完成
        // 0: 请求未初始化
        // 1: 服务器连接已建立
        // 2: 请求已接收
        // 3: 请求处理中
        // 4: 请求已完成，且响应已就绪
        if(xhr.readyState === 4){
            if(xhr.status === 200 || xhr.status === 304){
                console.log(xhr.responseText)
                if(success) {
                    success()
                }
            }
        }
    }
}
```

### 12、手写一个深拷贝

```java
function deepCopy(obj){
    //判断是否是简单数据类型，
    if(typeof obj == "object"){
        //复杂数据类型
        var result = obj.constructor == Array ? [] : {};
        for(let i in obj){
            result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i];
        }
    }else {
        //简单数据类型 直接 == 赋值
        var result = obj;
    }
    return result;
}
```

### 13、防抖函数、节流函数

**防抖**——触发高频函数事件后，n秒内函数只能执行一次，如果在n秒内这个事件再次被触发的话，那么会重新计算时间。

**节流**——高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。

```js
// 防抖函数
function debounce(fn, wait) {
    wait = wait || 0
    var timerId;
    function helper() {
        if(timerId) {
            clearTimeout(timerId)
            timerId = null
        }
        timerId = setTimeout(function() {
            fn()
        }, wait)
    }
    return helper
}

// 节流函数
function throttle(fn, holder) {
    var last;
    var timer;
    holder = holder || 500
    return function() {
        var context = this;
        var args = arguments
        var curTime = +new Date() 
        if(last && curTime < last + holder) {
            clearTimeout(timer)
            timer = setTimeout(function() {
                last = curTime
                fn.apply(context,args)
            }, holder)
        } else {
            last = curTime
            fn.apply(context, args)
        }
    }
}
```

### 14、Object.prototype.toString. call() 、 instanceof 以及 Array.isArray()的区别

**Object.prototype.toString.call()**

每一个继承`Object 的对象都有 toString`方法，如果`toString`方法没有重写的话，会返回`[Object type]`，其中`type`为对象的类型。但当除了`Object`类型的 对象外，其他类型直接使用`toString`方法时，会直接返回都是内容的字符串， 所以我们需要使用`call`或者`apply`方法来改变`toString`方法的执行上下文。

这种方法对于所有基本的数据类型都能进行判断，即使是`null`和`undefined`。`Object.prototype.toString.call()`常用于判断浏览器内置对象时。

```js
const an = ['Hello','An'];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an);  // "[object Array]" 
Object.prototype.toString.call('An'); // "[object String]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call(Symbol(1)); // "[object Symbol]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(function(){}); // "[object Function]"
Object.prototype.toString.call({name: 'An'}); // "[object Object]"
```

**instanceof **

`instanceof`的内部机制是通过判断对象的原型链中是不是能找到类型的`prototype`。 

使用`instanceof`判断一个对象是否为数组，`instanceof`会判断这个对象的原型链上是否会找到对应的`Array`的原型，找到返回`true`，否则返回`false`。

```js
 [] instanceof Array; // true
```

 但`instanceof`只能用来判断对象类型，原始类型不可以。并且所有对象类型`instanceof Object`都是 true。 

```js
[] instanceof Object; // true
```

**Array.isArray()**

功能：用来判断对象是否为数组

`instanceof`与`isArray`当检测到`Array`实例时，`Array.isArray`优于`instanceof`，因为`Array.isArray`可以检测出 `iframes`

```js
var iframe = document.createElement('iframe'); 
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length-1].Array; 
// Correctly checking for Array
var arr = new xArray(1,2,3); // [1,2,3]
Array.isArray(arr); // true
// Considered harmful, because doesn't work though iframes
Object.prototype.toString.call(arr); // true
arr instanceof Array; // false 
```

`Array.isArray()`是`ES5`新增的方法，当不存在`Array.isArray()`，可以用`Object.prototype.toString.call()`实现。

```js
if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    }; 
}
```

### 15、事件模型、怎么在事件捕获阶段触发事件

JavaScript事件模型主要分为3种：原始事件模型、DOM2事件模型、IE事件模型。

#### **原始事件模型**

这是一种被**所有浏览器都支持的事件模型**，对于原始事件而言，**没有事件流**，事件一旦发生将马上进行处理，有两种方式可以实现原始事件：

（1）在html代码中直接指定属性值：`<button id="demo" type="button" onclick="doSomeTing()" />`

（2）在js代码中为:`document.getElementsById("demo").onclick = doSomeTing()`

优点：所有浏览器都兼容

缺点：

1）逻辑与显示没有分离；

2）相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。

3）无法通过事件的冒泡、委托等机制（后面会讲到）完成更多事情。

#### **DOM2事件模型**

此模型是W3C制定的标准模型，现代浏览器（IE6~8除外）都已经遵循这个规范。W3C制定的事件模型中，一次事件的发生包含三个过程：(1).事件捕获阶段，(2).事件目标阶段，(3).事件冒泡阶段。

事件捕获：当某个元素触发某个事件（如onclick），顶层对象`document`就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。

事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。

事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。

所有的事件类型都会经历事件捕获但是只有部分事件会经历事件冒泡阶段,例如submit事件就不会被冒泡。 

**事件的传播是可以阻止的：**

　　• 在W3c中，使用`stopPropagation()`方法
　　• 在IE下设置`cancelBubble = true;`
　　在捕获的过程中`stopPropagation()`后，后面的冒泡过程就不会发生了。

**标准的事件监听器该如何绑定：**

`addEventListener("eventType","handler","true|false");`其中`eventType`指事件类型，**注意不要加`on`前缀，与IE下不同**。第二个参数是处理函数，第三个即用来指定是否在捕获阶段进行处理，一般设为false来与IE保持一致(默认设置)，除非你有特殊的逻辑需求。监听器的解除也类似：`removeEventListner("eventType","handler","true|false");`

#### **IE事件模型**

IE不把对象传到事件处理函数中，由于在任意时刻只会存在一个事件，所以IE把事件`Event`作为全局对象`window`的一个属性；`IE`的事件模型只有两步，先执行元素的监听函数，然后事件沿着父节点一直冒泡到`document`。绑定监听函数的方法是：`attachEvent( "eventType","handler")`，其中`evetType`为事件的类型，如`onclick`，注意要加`on`。解除事件监听器的方法是 `detachEvent("eventType","handler")`

#### 怎么在事件捕获阶段触发事件

在为事件绑定监听事件`addEventListener`时，将第三个参数设置为`true`就好.

### 16、各种排序算法的时间复杂度及空间复杂度

<img src="D:\typora笔记\面试复习题.assets\image-20201127142556767.png" alt="image-20201127142556767" style="zoom:67%;" />

### 17、各种查询算法的时间复杂度

<img src="D:\typora笔记\面试复习题.assets\image-20201127143012448.png" alt="image-20201127143012448" style="zoom:67%;" />

### 18、new的实现原理

1、创建一个空对象obj

2、将新对象 obj 的 `__proto__ `链接到构造函数的原型 prototype，

3、执行构造函数方法，将属性和方法添加到this引用的对象中

4、如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。

### 19、箭头函数为什么不能使用new

没有自己的 this，无法调用 call，apply。 

没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 `__proto__`

### 20、Promise

- Promise.prototype.then

实例方法，为 Promise 注册回调函数，函数形式：`fn (vlaue){}`，`value`是上一个任务的返回结果，`then`中的函数一定要`return`一个结果或者一个新的`Promise`对象，才可以让之后的`then`回调接收。

- Promise.prototype.catch

实例方法，捕获异常，函数形式：`fn(err){}`，`err`是`catch`注册 之前的回调抛出的异常信息。

- Promise.race

类方法，多个`Promise`任务同时执行，返回最先执行结束的`Promise`任务的结果，不管这个`Promise`结果是成功还是失败。

- Promise.all

类方法，多个`Promise`任务同时执行。如果全部成功执行，则以数组的方式返回所有`Promise`任务的执行结果。如果有一个`Promise`任务`rejected`，则只返回`rejected`任务的结果。

### 21、promise内部有几种状态

promise有三种状态：pending、reslove、reject 。

pending就是未解决，resolve为成功，reject为失败。

### 22、promise里面new Error()，用try catch可以捕获吗？

能。直接在调用链的末尾加上`.catch(error => alert(error))`

### 23、面向对象三大特性

三大特性：封装，继承，多态

封装
---->减少了大量的冗余代码
---->封装将复杂的功能封装起来，对外开放一个接口，简单调用即可。

继承–单根性，传递性
---->减少了类的冗余代码
---->让类与类之间产生关系，为多态打下基础

多态

实现多态，有二种方式，覆盖，重载。
覆盖，是指子类重新定义父类的虚函数的做法。
重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）

### 24、js操作dom的方法

```js
document.getElementById('');
document.getElementsByClassName('')
document.getElementsByTagName('')
document.querySelector('')
document.querySelectorAll('')
```

### 25、diff算法

diff算法其实就是对DOM进行比较不同的一种算法补丁：用来更新DOM

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202115424693.png" alt="image-20201202115424693" style="zoom:50%;" />

`patch`函数接收两个参数`Vnode`和`oldVnode`分别代表新的节点和之前的旧节点

如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明旧节点被改变了，就可以直接替换为新节点。

如果旧节点没有，则删除真实元素的子节点
如果旧节点没有子节点而新节点有，则将新节点的子节点添加到真实元素中
如果两者都有子节点，则执行`updateChildren`函数比较子节点

`updateChildren`函数主要作用是：将新旧节点的子节点提出来做比较

时间复杂度：所有的节点按层级比较，只会遍历一次，O(n)

### 26、单例怎么实现

单例模式，也叫单子模式，是一种常用的软件设计模式。单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。

<img src="D:\typora笔记\面试必看\面试复习题.assets\image-20201202114353419.png" alt="image-20201202114353419" style="zoom:67%;" />

### 27、let 、const和var的区别

一）var声明变量存在变量提升，let和const不存在变量提升；var定义的变量，没有块的概念，可以跨块访问，不能跨函数访问。

二）let、const都是块级局部变量，且使用const声明变量需要赋初始值，同时用const声明的变量如果是简单数据类型，那么只能进行一次赋值，即声明后不能再修改；如果声明的是复合类型数据，可以修改其属性

三）同一作用域下let和const不能声明同名变量，而var可以

### 28、作用域与作用域链

作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

当我们取一个变量的值的时候，在当前作用域查询不到，就会向上一级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

### 29、JavaScript继承方式

**原型链继承**

基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，即让原型对象等于另一个类型的实例；

**构造函数继承**

基本思想：在子类型构造函数的内部调用超类型构造函数，通过使用apply()和call()方法可以在将来新创建的对象上执行构造函数；

**组合继承**

基本思想：将原型链和借用构造函数技术组合到一起。使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性；

**原型式继承**

基本思想：不用严格意义上的构造函数，借助原型可以根据已有的对象创建新对象；

ES5新增Object.create规范了原型式继承，接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象，在传入一个参数的情况下，Object.create()和object()行为相同。

**寄生式继承**

基本思想：寄生式继承是与原型式继承紧密相关的一种思路，它创造一个仅用于封装继承过程的函数，在函数内部以某种方式增强对象，最后再返回对象。

**寄生组合式继承**

基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，不必为了指定子类型的原型而调用超类型的构造函数，只需要超类型的一个副本。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型

### 30、instanceof的原理

instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false

## 六、浏览器问题

### 1、什么是浏览器渲染(客户端渲染)？什么是服务器渲染

#### 客户端渲染

客户端渲染模式下，`html`仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，客户端拿到服务端发送过来的文件后执行一遍文件上的`JS文件`，根据`JS`运行结果，生成相应`DOM`并插入到`HTML`中，然后渲染给用户。

**优点**

后端只提供数据，前端做视图和交互逻辑，分工明确。服务器只提供接口，路由以及渲染都丢给前端，服务器计算压力变轻了。

**缺点**

用户等待时间变长了。

#### 服务器渲染

服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成`HTML`字符串，然后把它返回给客户端。客户端拿到服务端发送过来的数据，可以直接渲染，然后呈现给用户的`HTML`内容，不需要为了生成 `DOM `内容而去执行一遍` JS `代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找。

**优点**

响应很快，用户体验会比较好；对于搜索引擎来说也是友好的

**缺点**

增加了服务器计算压力

### 2、SessionStorag、localStorage、cookie和session的区别和优缺点

**区别**

三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。

SessionStorage和localStorage属于WebStorage，本地存储，存储在客户端

localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信

sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。

cookie和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。

cookie的有效期可以自己设置，如果没有自己设置一个有效期，那么当关闭当前页面或者关闭浏览器时cookie过期。由于cookie是保存在客户端，所以cookie不是很安全，黑客可以分析存放在本地的cookie，通过盗用伪造用户身份进行cookie欺骗。 cookie也分为永久和暂时存在的; 记住密码功能就是使用永久cookie写在客户端电脑，下次登录时，自动将cookie信息附加发送给服务端。

Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(longinterval)修改。由于session是保存在服务器上，每个用户都有一个独立的session，当有大量用户同时访问时会给服务器带来压力。浏览器页面一关闭，session也就失效了。

**优缺点**

cookie的优点：

具有极高的扩展性和可用性
通过良好的编程，控制保存在cookie中的session对象的大小
通过加密和安全传输技术，减少cookie被破解的可能性
只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失
控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie

cookie的缺点：

cookie的长度和数量的限制。每个cookie长度不能超过4KB，否则会被截掉。cookie会每次随http请求一起发送，浪费宽带。

localstorage优点：

可以大量保存浏览器中数据。不会随http请求一起发送

localstorage缺点：

不同窗口下数据；不能独立，相互干扰。

sessionstorage优点：

可以大量保存浏览器中数据。不同窗口下的sessionStorage，存储相互独立；互不干扰

sessionstorage缺点：

当页面关闭后，sessionStorage 中的数据就会被清空

### 3、cookie有哪些属性？浏览器如何禁止别人访问cookie

cookie的属性有：name(cookie的名称)、value(cookie的值)、domain(可以访问此cookie的域名)、path(以访问此cookie的页面路径)、Max-Age(字段为此cookie超时时间)、size(cookie大小)、http(cookie的httponly属性；若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie)、secure(设置是否只能通过https来传递此cookie)

通过设置浏览器的 Always send Do not Track header / 随浏览流量一起发送"不跟踪'请求 这一选项防止用户隐私被跟踪，保护用户网络隐私。	

### 4、从输入网址到获得页面的过程

#### （1）输入网址按回车键或点击跳转

#### （2）DNS域名解析，获取IP地址

在浏览器缓存、hosts文件、路由器缓存中查找url对应的IP地址。如果没有找到，则发起一个DNS请求到本地域名服务器，在其缓存中进行查找。如果没有，本地DNS服务器向根DNS服务器发起请求，根DNS服务器返回顶级DNS服务器的地址；本地DNS服务器向顶级DNS服务器发起请求，顶级DNS服务器返回权限DNS服务器的地址；本地DNS服务器向权限DNS服务器发起请求，权限DNS服务器查询到域名对应的IP后，将IP地址返回给本地DNS服务器；本地DNS服务器接收后将其保存到缓存中，以备下次查询。本地DNS服务器将IP地址返回给客户主机浏览器。

#### （3）浏览器向Web服务器发送HTTP请求

浏览器以一个随机的端口向服务器发起TCP连接请求。三次握手后，建立TCP连接。建立连接后，发送一个HTTP请求，包含请求行、请求头、请求正文

#### （4）服务器处理请求，返回HTTP响应

服务器接收到TCP报文后，对HTTP协议进行解析，然后将相应的数据封装为HTTP Request对象，供上层使用。HTTP响应，包括状态行、响应头、响应正文。

#### （5）浏览器下载web服务器返回的数据及解析htm|源文件

用户请求的HTML文档通过浏览器的网络层到达渲染引擎后，渲染工作开始。

### 5、从输入网址到网页渲染完成经历了什么

​	1）输入网址按回车键或点击跳转

​	2）发送到DNS服务器进行DNS解析，获取到我们对应web服务器对应的ip地址

​	3）与Web服务器建立TCP连接

​	4）浏览器向web服务器发送http请求

​	5）Web服务器进行响应请求并返回指定的url数据(当然这里也可能是错误信息或者重定向到信的urI地址等)

​	6）浏览器下载web服务器返回的数据及解析htm|源文件

​	7）根据文件生成DOM树和CSS规则树合成我们的渲染树，解析js，最后渲染我们的页面然后显示出来

### 6、浏览器的回流(重排)与重绘

涉及到浏览器渲染页面的过程，浏览器解析HTML生成DOM树，解析css生成css规则树，在DOM树和css规则树结合生成渲染树的过程中，需要计算每个节点的位置和大小，这个计算过程就是回流。在计算完节点的位置和大小后，需要将节点转换为屏幕中的实际像素，这个过程称为重绘。

**回流一定会引发重绘，重绘不一定会引起回流**

**何时发生回流重绘**

​	1）添加或者删除可见的DOM元素
​	2）元素的位置、尺寸发生变化
​	3）页面开始渲染的时候
​	4）浏览器的视口尺寸大小发生改变(因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小)

**如何避免发生回流重绘**

避免操作DOM操作

将需要多次回流的元素position属性设为absolute或fixed，这样该元素就会脱离文档流，它的变化不会影响其他元素变化。

避免使用`table`布局，一些很小的变化，会导致`table`中所有其他节点回流。

使用`visibility`替换`display: none`，因为前者只会引起重绘，后者会引发回流(改变了布局)

尽可能在`DOM`树的最末端改变`class`，回流是不可避免的，但可以减少其影响。尽可能在`DOM`树的最末端改变`class`，可以限制了回流的范围，使其影响尽可能少的节点。

### 7、前端`SEO`需要注意什么

（1）合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可。

（2）语义化的`HTML`代码，符合`W3C`规范：语义化代码让搜索引擎容易理解网页。

（3）重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。

（4）重要内容不要用`js`输出：爬虫不会执行`js`获取内容 

（5）少用`iframe`：搜索引擎不会抓取`iframe`中的内容 

（6）非装饰性图片必须加`alt `

### 8、移动端web页面适配方案

#### 8.1 百分比方案

使用 **百分比%** 定义 **宽度**，**高度** 用**`px`**固定，根据可视区域实时尺寸进行调整，尽可能适应各种分辨率，通常使用`max-width`/`min-width`控制尺寸范围过大或者过小。

##### 优势

原理简单，不存在兼容性问题

##### 不足

如果屏幕尺度跨度太大，相对设计稿过大或者过小的屏幕不能正常显示，在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化

#### 8.2 rem方案

**rem**是相对长度单位，rem方案中的样式设计为相对于**根元素**`font-size`计算值的倍数。根据 **屏幕宽度** 设置`html`标签的`font-size`，在布局时使用 **rem** 单位布局，达到自适应的目的，是 **弹性布局** 的一种实现方式。

##### 优势

兼容性好

##### 不足

不是纯css移动适配方案，需要引入js脚本，在头部内嵌一段 `js`脚本 **监听分辨率的变化来动态改变根元素的字体大小**，`css`样式和 `js` 代码有一定 **耦合性**，并且必须将改变`font-size`的代码放在 **css** 样式之前。

#### 8.3 vh/vw方案

用`vh(viewport height)`或者`vw(viewport width)`来表示元素的宽高。

**vw** : **1vw** 等于 **视口宽度** 的 **1%**

**vh** : **1vh** 等于 **视口高度** 的 **1% **

##### 优势

纯 **css** 移动端适配方案，不存在脚本依赖问题

相对于 **rem** 以**根元素字体大小的倍数** 定义 **元素大小**，逻辑清晰简单，视口单位依赖于视口的尺寸 `"1vw ＝ 1/100 viewport width"`，根据 **视口尺寸的百分比** 来定义 **元素宽度**

##### 不足

存在一些兼容性问题，Android4.4以下不支持

#### 8.4 基于媒体查询的响应式设计

**媒体查询**，通过给不同分辨率的设备编写不同的样式实现响应式布局，用于解决不同设备不同分辨率之间兼容问题，一般是指PC、平板、手机设备之间较大的分辨率差异。实现上不局限于具体的方案，通常结合了 **流式布局** `+` **弹性布局** 方案。

```css
@media only screen and (min-width: 375px){
    样式1
}
@media only screen and (min-width: 750){
    样式2
}
```

能够使网页在不同设备、不同分辨率屏幕上呈现合理布局，不仅仅是样式伸缩变换

##### 不足

要匹配足够多的设备与屏幕，一个web页面需要多个设计方案，工作量比较大

### 9、浏览器的缓存机制是什么

即**http缓存**